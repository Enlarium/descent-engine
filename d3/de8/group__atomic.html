<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Descent Engine: Atomic</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Descent Engine<span id="projectnumber">&#160;0.0.0-dev</span>
   </div>
   <div id="projectbrief">Descent Engine</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">Atomic<div class="ingroups"><a class="el" href="../../da/dd8/group__thread.html">Thread</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>Low-level atomic types and operations.  
<a href="#details">More...</a></p>
<div class="dynheader">
Collaboration diagram for Atomic:</div>
<div class="dyncontent">
<div class="center"><img src="../../d3/de8/group__atomic.png" border="0" usemap="#ad3_2de8_2group____atomic" alt=""/></div>
<map name="ad3_2de8_2group____atomic" id="ad3_2de8_2group____atomic">
<area shape="rect" title="Low&#45;level atomic types and operations." alt="" coords="120,5,188,31"/>
<area shape="rect" href="../../da/dd8/group__thread.html" title="Threading and synchronization primitives." alt="" coords="5,5,72,31"/>
</map>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d09/structatomic__int.html">atomic_int</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomic integer type.  <a href="../../db/d09/structatomic__int.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d44/structatomic__32.html">atomic_32</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomic 32-bit unsigned integer type.  <a href="../../dc/d44/structatomic__32.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d8a/structatomic__64.html">atomic_64</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomic 64-bit unsigned integer type.  <a href="../../df/d8a/structatomic__64.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d3d/structatomic__ptr.html">atomic_ptr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomic pointer type.  <a href="../../dc/d3d/structatomic__ptr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d98/structatomic__bool.html">atomic_bool</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomic boolean type.  <a href="../../db/d98/structatomic__bool.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga4469771b4363d1d81287967e30453e44" id="r_ga4469771b4363d1d81287967e30453e44"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/de8/group__atomic.html#ga4469771b4363d1d81287967e30453e44">atomic_always_lock_free</a>(ptr)&#160;&#160;&#160;__atomic_always_lock_free(sizeof(*(ptr)), ptr)</td></tr>
<tr class="memdesc:ga4469771b4363d1d81287967e30453e44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates whether atomic operations on the given type are always lock-free.  <br /></td></tr>
<tr class="separator:ga4469771b4363d1d81287967e30453e44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa2ad8d7ede74b9c5860cd4628cc2b355" id="r_gaa2ad8d7ede74b9c5860cd4628cc2b355"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/de8/group__atomic.html#gaa2ad8d7ede74b9c5860cd4628cc2b355">atomic_is_lock_free</a>(ptr)&#160;&#160;&#160;__atomic_is_lock_free(sizeof(*(ptr)), ptr)</td></tr>
<tr class="memdesc:gaa2ad8d7ede74b9c5860cd4628cc2b355"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates whether atomic operations on the given object are lock-free.  <br /></td></tr>
<tr class="separator:gaa2ad8d7ede74b9c5860cd4628cc2b355"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7b208150b120d2cc41ace2441560fb67" id="r_ga7b208150b120d2cc41ace2441560fb67"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/de8/group__atomic.html#ga7b208150b120d2cc41ace2441560fb67">ATOMIC_INIT</a>(value)&#160;&#160;&#160;{ ._atomic = value }</td></tr>
<tr class="memdesc:ga7b208150b120d2cc41ace2441560fb67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Static initializer for atomic objects.  <br /></td></tr>
<tr class="separator:ga7b208150b120d2cc41ace2441560fb67"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ga0411cd49bb5b71852cecd93bcbf0ca2d" id="r_ga0411cd49bb5b71852cecd93bcbf0ca2d"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <br />
&#160;&#160;<a class="el" href="../../d3/de8/group__atomic.html#gga0411cd49bb5b71852cecd93bcbf0ca2daa5df71bfeb8f16c508776c55e613ca86">ATOMIC_RELAXED</a> = __ATOMIC_RELAXED
, <a class="el" href="../../d3/de8/group__atomic.html#gga0411cd49bb5b71852cecd93bcbf0ca2da3c9cb31f4d7c87eb9cefc73f6170587c">ATOMIC_ACQUIRE</a> = __ATOMIC_ACQUIRE
, <a class="el" href="../../d3/de8/group__atomic.html#gga0411cd49bb5b71852cecd93bcbf0ca2da2b107cf2c6dce64b5e987cd0d4b4f8d3">ATOMIC_RELEASE</a> = __ATOMIC_RELEASE
, <a class="el" href="../../d3/de8/group__atomic.html#gga0411cd49bb5b71852cecd93bcbf0ca2da64012698a77715fca7ec6e2724d7bf5e">ATOMIC_ACQ_REL</a> = __ATOMIC_ACQ_REL
, <br />
&#160;&#160;<a class="el" href="../../d3/de8/group__atomic.html#gga0411cd49bb5b71852cecd93bcbf0ca2da388308897863e62b26231a119b5020bc">ATOMIC_SEQ_CST</a> = __ATOMIC_SEQ_CST
<br />
 }</td></tr>
<tr class="memdesc:ga0411cd49bb5b71852cecd93bcbf0ca2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Memory ordering constraints for atomic operations.  <a href="../../d3/de8/group__atomic.html#ga0411cd49bb5b71852cecd93bcbf0ca2d">More...</a><br /></td></tr>
<tr class="separator:ga0411cd49bb5b71852cecd93bcbf0ca2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga84eb183e153040448c91365eff70e33a" id="r_ga84eb183e153040448c91365eff70e33a"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/de8/group__atomic.html#ga84eb183e153040448c91365eff70e33a">atomic_load_int</a> (<a class="el" href="../../db/d09/structatomic__int.html">atomic_int</a> *ptr, int order)</td></tr>
<tr class="memdesc:ga84eb183e153040448c91365eff70e33a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomically loads the value of an atomic integer and returns it.  <br /></td></tr>
<tr class="separator:ga84eb183e153040448c91365eff70e33a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaafcfd70fabfbb2246d86b9ecbb45fd17" id="r_gaafcfd70fabfbb2246d86b9ecbb45fd17"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/de8/group__atomic.html#gaafcfd70fabfbb2246d86b9ecbb45fd17">atomic_store_int</a> (<a class="el" href="../../db/d09/structatomic__int.html">atomic_int</a> *ptr, int val, int order)</td></tr>
<tr class="memdesc:gaafcfd70fabfbb2246d86b9ecbb45fd17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomically stores a value into an atomic integer.  <br /></td></tr>
<tr class="separator:gaafcfd70fabfbb2246d86b9ecbb45fd17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga54d4e5749dce93db16225efe211b964a" id="r_ga54d4e5749dce93db16225efe211b964a"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/de8/group__atomic.html#ga54d4e5749dce93db16225efe211b964a">atomic_exchange_int</a> (<a class="el" href="../../db/d09/structatomic__int.html">atomic_int</a> *ptr, int val, int order)</td></tr>
<tr class="memdesc:ga54d4e5749dce93db16225efe211b964a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomically stores a value into an atomic integer and returns the old value.  <br /></td></tr>
<tr class="separator:ga54d4e5749dce93db16225efe211b964a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga431b27ed78f204d45a9f565c801e8151" id="r_ga431b27ed78f204d45a9f565c801e8151"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/de8/group__atomic.html#ga431b27ed78f204d45a9f565c801e8151">atomic_compare_exchange_int</a> (<a class="el" href="../../db/d09/structatomic__int.html">atomic_int</a> *ptr, int *expected, int desired, int success_order, int failure_order)</td></tr>
<tr class="memdesc:ga431b27ed78f204d45a9f565c801e8151"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomically compares the value of an atomic integer with an expected value and, if they are equal, replaces it with a desired value.  <br /></td></tr>
<tr class="separator:ga431b27ed78f204d45a9f565c801e8151"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga01b53f8e08eb42b75d044826a2923fe8" id="r_ga01b53f8e08eb42b75d044826a2923fe8"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/de8/group__atomic.html#ga01b53f8e08eb42b75d044826a2923fe8">atomic_add_fetch_int</a> (<a class="el" href="../../db/d09/structatomic__int.html">atomic_int</a> *ptr, int val, int order)</td></tr>
<tr class="memdesc:ga01b53f8e08eb42b75d044826a2923fe8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomically adds a value to an atomic integer and returns the new value.  <br /></td></tr>
<tr class="separator:ga01b53f8e08eb42b75d044826a2923fe8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9e217ddededa9cc15a6c4d1db7c75179" id="r_ga9e217ddededa9cc15a6c4d1db7c75179"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/de8/group__atomic.html#ga9e217ddededa9cc15a6c4d1db7c75179">atomic_sub_fetch_int</a> (<a class="el" href="../../db/d09/structatomic__int.html">atomic_int</a> *ptr, int val, int order)</td></tr>
<tr class="memdesc:ga9e217ddededa9cc15a6c4d1db7c75179"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomically subtracts a value from an atomic integer and returns the new value.  <br /></td></tr>
<tr class="separator:ga9e217ddededa9cc15a6c4d1db7c75179"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga01f12416cf4caf8524ce89a55f0f25c9" id="r_ga01f12416cf4caf8524ce89a55f0f25c9"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/de8/group__atomic.html#ga01f12416cf4caf8524ce89a55f0f25c9">atomic_and_fetch_int</a> (<a class="el" href="../../db/d09/structatomic__int.html">atomic_int</a> *ptr, int val, int order)</td></tr>
<tr class="memdesc:ga01f12416cf4caf8524ce89a55f0f25c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomically performs a bitwise AND between an atomic integer and a value, storing the result into the atomic integer and returning it.  <br /></td></tr>
<tr class="separator:ga01f12416cf4caf8524ce89a55f0f25c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaddeba6725c63db1f1e70659270aa1ab4" id="r_gaddeba6725c63db1f1e70659270aa1ab4"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/de8/group__atomic.html#gaddeba6725c63db1f1e70659270aa1ab4">atomic_xor_fetch_int</a> (<a class="el" href="../../db/d09/structatomic__int.html">atomic_int</a> *ptr, int val, int order)</td></tr>
<tr class="memdesc:gaddeba6725c63db1f1e70659270aa1ab4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomically performs a bitwise XOR between an atomic integer and a value, storing the result into the atomic integer and returning it.  <br /></td></tr>
<tr class="separator:gaddeba6725c63db1f1e70659270aa1ab4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9a3bea073c0fbbce302e1168b9afb02a" id="r_ga9a3bea073c0fbbce302e1168b9afb02a"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/de8/group__atomic.html#ga9a3bea073c0fbbce302e1168b9afb02a">atomic_or_fetch_int</a> (<a class="el" href="../../db/d09/structatomic__int.html">atomic_int</a> *ptr, int val, int order)</td></tr>
<tr class="memdesc:ga9a3bea073c0fbbce302e1168b9afb02a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomically performs a bitwise OR between an atomic integer and a value, storing the result into the atomic integer and returning it.  <br /></td></tr>
<tr class="separator:ga9a3bea073c0fbbce302e1168b9afb02a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0e44f7d96ed6f6e037ffd6b81f2f43f5" id="r_ga0e44f7d96ed6f6e037ffd6b81f2f43f5"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/de8/group__atomic.html#ga0e44f7d96ed6f6e037ffd6b81f2f43f5">atomic_nand_fetch_int</a> (<a class="el" href="../../db/d09/structatomic__int.html">atomic_int</a> *ptr, int val, int order)</td></tr>
<tr class="memdesc:ga0e44f7d96ed6f6e037ffd6b81f2f43f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomically performs a bitwise NAND between an atomic integer and a value, storing the result into the atomic integer and returning it.  <br /></td></tr>
<tr class="separator:ga0e44f7d96ed6f6e037ffd6b81f2f43f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaff0de9ccfd4c10e7230e5ae0acb0f3f3" id="r_gaff0de9ccfd4c10e7230e5ae0acb0f3f3"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/de8/group__atomic.html#gaff0de9ccfd4c10e7230e5ae0acb0f3f3">atomic_fetch_add_int</a> (<a class="el" href="../../db/d09/structatomic__int.html">atomic_int</a> *ptr, int val, int order)</td></tr>
<tr class="memdesc:gaff0de9ccfd4c10e7230e5ae0acb0f3f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomically adds a value to an atomic integer and returns the old value.  <br /></td></tr>
<tr class="separator:gaff0de9ccfd4c10e7230e5ae0acb0f3f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7ba417c1216dae3d9fb2baedaa066344" id="r_ga7ba417c1216dae3d9fb2baedaa066344"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/de8/group__atomic.html#ga7ba417c1216dae3d9fb2baedaa066344">atomic_fetch_sub_int</a> (<a class="el" href="../../db/d09/structatomic__int.html">atomic_int</a> *ptr, int val, int order)</td></tr>
<tr class="memdesc:ga7ba417c1216dae3d9fb2baedaa066344"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomically subtracts a value from an atomic integer and returns the old value.  <br /></td></tr>
<tr class="separator:ga7ba417c1216dae3d9fb2baedaa066344"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0fe797f4715a91f026c9ccf20bcad80e" id="r_ga0fe797f4715a91f026c9ccf20bcad80e"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/de8/group__atomic.html#ga0fe797f4715a91f026c9ccf20bcad80e">atomic_fetch_and_int</a> (<a class="el" href="../../db/d09/structatomic__int.html">atomic_int</a> *ptr, int val, int order)</td></tr>
<tr class="memdesc:ga0fe797f4715a91f026c9ccf20bcad80e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomically performs a bitwise AND between an atomic integer and a value, storing the result into the atomic integer and returning the old value.  <br /></td></tr>
<tr class="separator:ga0fe797f4715a91f026c9ccf20bcad80e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadd38601cc45a12c59d59599488314aae" id="r_gadd38601cc45a12c59d59599488314aae"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/de8/group__atomic.html#gadd38601cc45a12c59d59599488314aae">atomic_fetch_xor_int</a> (<a class="el" href="../../db/d09/structatomic__int.html">atomic_int</a> *ptr, int val, int order)</td></tr>
<tr class="memdesc:gadd38601cc45a12c59d59599488314aae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomically performs a bitwise XOR between an atomic integer and a value, storing the result into the atomic integer and returning the old value.  <br /></td></tr>
<tr class="separator:gadd38601cc45a12c59d59599488314aae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf86cdfabf01f6b6cf2f78b3f46371d18" id="r_gaf86cdfabf01f6b6cf2f78b3f46371d18"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/de8/group__atomic.html#gaf86cdfabf01f6b6cf2f78b3f46371d18">atomic_fetch_or_int</a> (<a class="el" href="../../db/d09/structatomic__int.html">atomic_int</a> *ptr, int val, int order)</td></tr>
<tr class="memdesc:gaf86cdfabf01f6b6cf2f78b3f46371d18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomically performs a bitwise OR between an atomic integer and a value, storing the result into the atomic integer and returning the old value.  <br /></td></tr>
<tr class="separator:gaf86cdfabf01f6b6cf2f78b3f46371d18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1fffc6bd0faf219c0eebaae86c511665" id="r_ga1fffc6bd0faf219c0eebaae86c511665"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/de8/group__atomic.html#ga1fffc6bd0faf219c0eebaae86c511665">atomic_fetch_nand_int</a> (<a class="el" href="../../db/d09/structatomic__int.html">atomic_int</a> *ptr, int val, int order)</td></tr>
<tr class="memdesc:ga1fffc6bd0faf219c0eebaae86c511665"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomically performs a bitwise NAND between an atomic integer and a value, storing the result into the atomic integer and returning the old value.  <br /></td></tr>
<tr class="separator:ga1fffc6bd0faf219c0eebaae86c511665"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6283d393417c6be988d8e3e0fa80840e" id="r_ga6283d393417c6be988d8e3e0fa80840e"><td class="memItemLeft" align="right" valign="top">static uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/de8/group__atomic.html#ga6283d393417c6be988d8e3e0fa80840e">atomic_load_32</a> (<a class="el" href="../../dc/d44/structatomic__32.html">atomic_32</a> *ptr, int order)</td></tr>
<tr class="memdesc:ga6283d393417c6be988d8e3e0fa80840e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomically loads the value of an atomic uint32_t and returns it.  <br /></td></tr>
<tr class="separator:ga6283d393417c6be988d8e3e0fa80840e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa3e6ed3cffc530d86f0fcd3bb55d85c5" id="r_gaa3e6ed3cffc530d86f0fcd3bb55d85c5"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/de8/group__atomic.html#gaa3e6ed3cffc530d86f0fcd3bb55d85c5">atomic_store_32</a> (<a class="el" href="../../dc/d44/structatomic__32.html">atomic_32</a> *ptr, uint32_t val, int order)</td></tr>
<tr class="memdesc:gaa3e6ed3cffc530d86f0fcd3bb55d85c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomically stores a value into an atomic uint32_t.  <br /></td></tr>
<tr class="separator:gaa3e6ed3cffc530d86f0fcd3bb55d85c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf0b172c9df42030baeb6f7b81ba8249a" id="r_gaf0b172c9df42030baeb6f7b81ba8249a"><td class="memItemLeft" align="right" valign="top">static uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/de8/group__atomic.html#gaf0b172c9df42030baeb6f7b81ba8249a">atomic_exchange_32</a> (<a class="el" href="../../dc/d44/structatomic__32.html">atomic_32</a> *ptr, uint32_t val, int order)</td></tr>
<tr class="memdesc:gaf0b172c9df42030baeb6f7b81ba8249a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomically stores a value into an atomic uint32_t and returns the old value.  <br /></td></tr>
<tr class="separator:gaf0b172c9df42030baeb6f7b81ba8249a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6c3434dce8a4b5abf22ca26374ddfba6" id="r_ga6c3434dce8a4b5abf22ca26374ddfba6"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/de8/group__atomic.html#ga6c3434dce8a4b5abf22ca26374ddfba6">atomic_compare_exchange_32</a> (<a class="el" href="../../dc/d44/structatomic__32.html">atomic_32</a> *ptr, uint32_t *expected, uint32_t desired, int success_order, int failure_order)</td></tr>
<tr class="memdesc:ga6c3434dce8a4b5abf22ca26374ddfba6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomically compares the value of an atomic uint32_t with an expected value and, if they are equal, replaces it with a desired value.  <br /></td></tr>
<tr class="separator:ga6c3434dce8a4b5abf22ca26374ddfba6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga38b33b65d5a85491bbbd97f555db9649" id="r_ga38b33b65d5a85491bbbd97f555db9649"><td class="memItemLeft" align="right" valign="top">static uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/de8/group__atomic.html#ga38b33b65d5a85491bbbd97f555db9649">atomic_add_fetch_32</a> (<a class="el" href="../../dc/d44/structatomic__32.html">atomic_32</a> *ptr, uint32_t val, int order)</td></tr>
<tr class="memdesc:ga38b33b65d5a85491bbbd97f555db9649"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomically adds a value to an atomic uint32_t and returns the new value.  <br /></td></tr>
<tr class="separator:ga38b33b65d5a85491bbbd97f555db9649"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga912bb344c291acd613c709eaab7be976" id="r_ga912bb344c291acd613c709eaab7be976"><td class="memItemLeft" align="right" valign="top">static uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/de8/group__atomic.html#ga912bb344c291acd613c709eaab7be976">atomic_sub_fetch_32</a> (<a class="el" href="../../dc/d44/structatomic__32.html">atomic_32</a> *ptr, uint32_t val, int order)</td></tr>
<tr class="memdesc:ga912bb344c291acd613c709eaab7be976"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomically subtracts a value from an atomic uint32_t and returns the new value.  <br /></td></tr>
<tr class="separator:ga912bb344c291acd613c709eaab7be976"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4dfeede756859ad30ac13f5848c454ce" id="r_ga4dfeede756859ad30ac13f5848c454ce"><td class="memItemLeft" align="right" valign="top">static uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/de8/group__atomic.html#ga4dfeede756859ad30ac13f5848c454ce">atomic_and_fetch_32</a> (<a class="el" href="../../dc/d44/structatomic__32.html">atomic_32</a> *ptr, uint32_t val, int order)</td></tr>
<tr class="memdesc:ga4dfeede756859ad30ac13f5848c454ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomically performs a bitwise AND between an atomic uint32_t and a value, storing the result into the atomic uint32_t and returning it.  <br /></td></tr>
<tr class="separator:ga4dfeede756859ad30ac13f5848c454ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga62235210f5186281d0a45f5f7d9b51e0" id="r_ga62235210f5186281d0a45f5f7d9b51e0"><td class="memItemLeft" align="right" valign="top">static uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/de8/group__atomic.html#ga62235210f5186281d0a45f5f7d9b51e0">atomic_xor_fetch_32</a> (<a class="el" href="../../dc/d44/structatomic__32.html">atomic_32</a> *ptr, uint32_t val, int order)</td></tr>
<tr class="memdesc:ga62235210f5186281d0a45f5f7d9b51e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomically performs a bitwise XOR between an atomic uint32_t and a value, storing the result into the atomic uint32_t and returning it.  <br /></td></tr>
<tr class="separator:ga62235210f5186281d0a45f5f7d9b51e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga78e5c7c54ffb6c6f9babada13127838e" id="r_ga78e5c7c54ffb6c6f9babada13127838e"><td class="memItemLeft" align="right" valign="top">static uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/de8/group__atomic.html#ga78e5c7c54ffb6c6f9babada13127838e">atomic_or_fetch_32</a> (<a class="el" href="../../dc/d44/structatomic__32.html">atomic_32</a> *ptr, uint32_t val, int order)</td></tr>
<tr class="memdesc:ga78e5c7c54ffb6c6f9babada13127838e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomically performs a bitwise OR between an atomic uint32_t and a value, storing the result into the atomic uint32_t and returning it.  <br /></td></tr>
<tr class="separator:ga78e5c7c54ffb6c6f9babada13127838e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadf1370191221205c583a8b475059d2d7" id="r_gadf1370191221205c583a8b475059d2d7"><td class="memItemLeft" align="right" valign="top">static uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/de8/group__atomic.html#gadf1370191221205c583a8b475059d2d7">atomic_nand_fetch_32</a> (<a class="el" href="../../dc/d44/structatomic__32.html">atomic_32</a> *ptr, uint32_t val, int order)</td></tr>
<tr class="memdesc:gadf1370191221205c583a8b475059d2d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomically performs a bitwise NAND between an atomic uint32_t and a value, storing the result into the atomic uint32_t and returning it.  <br /></td></tr>
<tr class="separator:gadf1370191221205c583a8b475059d2d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga187929c3a34e71e3f9d2befdacf2cc49" id="r_ga187929c3a34e71e3f9d2befdacf2cc49"><td class="memItemLeft" align="right" valign="top">static uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/de8/group__atomic.html#ga187929c3a34e71e3f9d2befdacf2cc49">atomic_fetch_add_32</a> (<a class="el" href="../../dc/d44/structatomic__32.html">atomic_32</a> *ptr, uint32_t val, int order)</td></tr>
<tr class="memdesc:ga187929c3a34e71e3f9d2befdacf2cc49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomically adds a value to an atomic uint32_t and returns the old value.  <br /></td></tr>
<tr class="separator:ga187929c3a34e71e3f9d2befdacf2cc49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8bb107a26f061f724190df6fbe706e5c" id="r_ga8bb107a26f061f724190df6fbe706e5c"><td class="memItemLeft" align="right" valign="top">static uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/de8/group__atomic.html#ga8bb107a26f061f724190df6fbe706e5c">atomic_fetch_sub_32</a> (<a class="el" href="../../dc/d44/structatomic__32.html">atomic_32</a> *ptr, uint32_t val, int order)</td></tr>
<tr class="memdesc:ga8bb107a26f061f724190df6fbe706e5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomically subtracts a value from an atomic uint32_t and returns the old value.  <br /></td></tr>
<tr class="separator:ga8bb107a26f061f724190df6fbe706e5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5e14080babc394daa3070ea86360657a" id="r_ga5e14080babc394daa3070ea86360657a"><td class="memItemLeft" align="right" valign="top">static uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/de8/group__atomic.html#ga5e14080babc394daa3070ea86360657a">atomic_fetch_and_32</a> (<a class="el" href="../../dc/d44/structatomic__32.html">atomic_32</a> *ptr, uint32_t val, int order)</td></tr>
<tr class="memdesc:ga5e14080babc394daa3070ea86360657a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomically performs a bitwise AND between an atomic uint32_t and a value, storing the result into the atomic uint32_t and returning the old value.  <br /></td></tr>
<tr class="separator:ga5e14080babc394daa3070ea86360657a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga49f8a8c9ce9c486fdc43f145446a0fbc" id="r_ga49f8a8c9ce9c486fdc43f145446a0fbc"><td class="memItemLeft" align="right" valign="top">static uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/de8/group__atomic.html#ga49f8a8c9ce9c486fdc43f145446a0fbc">atomic_fetch_xor_32</a> (<a class="el" href="../../dc/d44/structatomic__32.html">atomic_32</a> *ptr, uint32_t val, int order)</td></tr>
<tr class="memdesc:ga49f8a8c9ce9c486fdc43f145446a0fbc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomically performs a bitwise XOR between an atomic uint32_t and a value, storing the result into the atomic uint32_t and returning the old value.  <br /></td></tr>
<tr class="separator:ga49f8a8c9ce9c486fdc43f145446a0fbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga648b3777d353f9b55093978c38964612" id="r_ga648b3777d353f9b55093978c38964612"><td class="memItemLeft" align="right" valign="top">static uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/de8/group__atomic.html#ga648b3777d353f9b55093978c38964612">atomic_fetch_or_32</a> (<a class="el" href="../../dc/d44/structatomic__32.html">atomic_32</a> *ptr, uint32_t val, int order)</td></tr>
<tr class="memdesc:ga648b3777d353f9b55093978c38964612"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomically performs a bitwise OR between an atomic uint32_t and a value, storing the result into the atomic uint32_t and returning the old value.  <br /></td></tr>
<tr class="separator:ga648b3777d353f9b55093978c38964612"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga23238a31680d46978f6e16497c49a831" id="r_ga23238a31680d46978f6e16497c49a831"><td class="memItemLeft" align="right" valign="top">static uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/de8/group__atomic.html#ga23238a31680d46978f6e16497c49a831">atomic_fetch_nand_32</a> (<a class="el" href="../../dc/d44/structatomic__32.html">atomic_32</a> *ptr, uint32_t val, int order)</td></tr>
<tr class="memdesc:ga23238a31680d46978f6e16497c49a831"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomically performs a bitwise NAND between an atomic uint32_t and a value, storing the result into the atomic uint32_t and returning the old value.  <br /></td></tr>
<tr class="separator:ga23238a31680d46978f6e16497c49a831"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaaf0a1963bfa6d28bc8a01c0d7bcb6ed" id="r_gaaaf0a1963bfa6d28bc8a01c0d7bcb6ed"><td class="memItemLeft" align="right" valign="top">static uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/de8/group__atomic.html#gaaaf0a1963bfa6d28bc8a01c0d7bcb6ed">atomic_load_64</a> (<a class="el" href="../../df/d8a/structatomic__64.html">atomic_64</a> *ptr, int order)</td></tr>
<tr class="memdesc:gaaaf0a1963bfa6d28bc8a01c0d7bcb6ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomically loads the value of an atomic uint64_t and returns it.  <br /></td></tr>
<tr class="separator:gaaaf0a1963bfa6d28bc8a01c0d7bcb6ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab3c4ec522918b3bd9da1cf7f91f1d4d5" id="r_gab3c4ec522918b3bd9da1cf7f91f1d4d5"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/de8/group__atomic.html#gab3c4ec522918b3bd9da1cf7f91f1d4d5">atomic_store_64</a> (<a class="el" href="../../df/d8a/structatomic__64.html">atomic_64</a> *ptr, uint64_t val, int order)</td></tr>
<tr class="memdesc:gab3c4ec522918b3bd9da1cf7f91f1d4d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomically stores a value into an atomic uint64_t.  <br /></td></tr>
<tr class="separator:gab3c4ec522918b3bd9da1cf7f91f1d4d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga261933ebaa9e4515aa6d160458115129" id="r_ga261933ebaa9e4515aa6d160458115129"><td class="memItemLeft" align="right" valign="top">static uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/de8/group__atomic.html#ga261933ebaa9e4515aa6d160458115129">atomic_exchange_64</a> (<a class="el" href="../../df/d8a/structatomic__64.html">atomic_64</a> *ptr, uint64_t val, int order)</td></tr>
<tr class="memdesc:ga261933ebaa9e4515aa6d160458115129"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomically stores a value into an atomic uint64_t and returns the old value.  <br /></td></tr>
<tr class="separator:ga261933ebaa9e4515aa6d160458115129"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga50163a1d7c1891feb8902c332c37304b" id="r_ga50163a1d7c1891feb8902c332c37304b"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/de8/group__atomic.html#ga50163a1d7c1891feb8902c332c37304b">atomic_compare_exchange_64</a> (<a class="el" href="../../df/d8a/structatomic__64.html">atomic_64</a> *ptr, uint64_t *expected, uint64_t desired, int success_order, int failure_order)</td></tr>
<tr class="memdesc:ga50163a1d7c1891feb8902c332c37304b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomically compares the value of an atomic uint64_t with an expected value and, if they are equal, replaces it with a desired value.  <br /></td></tr>
<tr class="separator:ga50163a1d7c1891feb8902c332c37304b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae792ada5ceb73c7b77a02642675fcf1e" id="r_gae792ada5ceb73c7b77a02642675fcf1e"><td class="memItemLeft" align="right" valign="top">static uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/de8/group__atomic.html#gae792ada5ceb73c7b77a02642675fcf1e">atomic_add_fetch_64</a> (<a class="el" href="../../df/d8a/structatomic__64.html">atomic_64</a> *ptr, uint64_t val, int order)</td></tr>
<tr class="memdesc:gae792ada5ceb73c7b77a02642675fcf1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomically adds a value to an atomic uint64_t and returns the new value.  <br /></td></tr>
<tr class="separator:gae792ada5ceb73c7b77a02642675fcf1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7366eeb0afebd87dd96739cd5dd0666e" id="r_ga7366eeb0afebd87dd96739cd5dd0666e"><td class="memItemLeft" align="right" valign="top">static uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/de8/group__atomic.html#ga7366eeb0afebd87dd96739cd5dd0666e">atomic_sub_fetch_64</a> (<a class="el" href="../../df/d8a/structatomic__64.html">atomic_64</a> *ptr, uint64_t val, int order)</td></tr>
<tr class="memdesc:ga7366eeb0afebd87dd96739cd5dd0666e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomically subtracts a value from an atomic uint64_t and returns the new value.  <br /></td></tr>
<tr class="separator:ga7366eeb0afebd87dd96739cd5dd0666e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa11a79c0b15a2d72da0be0083311cee7" id="r_gaa11a79c0b15a2d72da0be0083311cee7"><td class="memItemLeft" align="right" valign="top">static uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/de8/group__atomic.html#gaa11a79c0b15a2d72da0be0083311cee7">atomic_and_fetch_64</a> (<a class="el" href="../../df/d8a/structatomic__64.html">atomic_64</a> *ptr, uint64_t val, int order)</td></tr>
<tr class="memdesc:gaa11a79c0b15a2d72da0be0083311cee7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomically performs a bitwise AND between an atomic uint64_t and a value, storing the result into the atomic uint64_t and returning it.  <br /></td></tr>
<tr class="separator:gaa11a79c0b15a2d72da0be0083311cee7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeae84496d9d07234d55260e583710e6a" id="r_gaeae84496d9d07234d55260e583710e6a"><td class="memItemLeft" align="right" valign="top">static uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/de8/group__atomic.html#gaeae84496d9d07234d55260e583710e6a">atomic_xor_fetch_64</a> (<a class="el" href="../../df/d8a/structatomic__64.html">atomic_64</a> *ptr, uint64_t val, int order)</td></tr>
<tr class="memdesc:gaeae84496d9d07234d55260e583710e6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomically performs a bitwise XOR between an atomic uint64_t and a value, storing the result into the atomic uint64_t and returning it.  <br /></td></tr>
<tr class="separator:gaeae84496d9d07234d55260e583710e6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga51e82db2349a422d1841a175fe0bfca6" id="r_ga51e82db2349a422d1841a175fe0bfca6"><td class="memItemLeft" align="right" valign="top">static uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/de8/group__atomic.html#ga51e82db2349a422d1841a175fe0bfca6">atomic_or_fetch_64</a> (<a class="el" href="../../df/d8a/structatomic__64.html">atomic_64</a> *ptr, uint64_t val, int order)</td></tr>
<tr class="memdesc:ga51e82db2349a422d1841a175fe0bfca6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomically performs a bitwise OR between an atomic uint64_t and a value, storing the result into the atomic uint64_t and returning it.  <br /></td></tr>
<tr class="separator:ga51e82db2349a422d1841a175fe0bfca6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaec7a37c031d8ef2b7124164d13db1efd" id="r_gaec7a37c031d8ef2b7124164d13db1efd"><td class="memItemLeft" align="right" valign="top">static uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/de8/group__atomic.html#gaec7a37c031d8ef2b7124164d13db1efd">atomic_nand_fetch_64</a> (<a class="el" href="../../df/d8a/structatomic__64.html">atomic_64</a> *ptr, uint64_t val, int order)</td></tr>
<tr class="memdesc:gaec7a37c031d8ef2b7124164d13db1efd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomically performs a bitwise NAND between an atomic uint64_t and a value, storing the result into the atomic uint64_t and returning it.  <br /></td></tr>
<tr class="separator:gaec7a37c031d8ef2b7124164d13db1efd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga55d72381175d559619ace69704671e3e" id="r_ga55d72381175d559619ace69704671e3e"><td class="memItemLeft" align="right" valign="top">static uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/de8/group__atomic.html#ga55d72381175d559619ace69704671e3e">atomic_fetch_add_64</a> (<a class="el" href="../../df/d8a/structatomic__64.html">atomic_64</a> *ptr, uint64_t val, int order)</td></tr>
<tr class="memdesc:ga55d72381175d559619ace69704671e3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomically adds a value to an atomic uint64_t and returns the old value.  <br /></td></tr>
<tr class="separator:ga55d72381175d559619ace69704671e3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3d594a57773416b5a9c91d46fb52f904" id="r_ga3d594a57773416b5a9c91d46fb52f904"><td class="memItemLeft" align="right" valign="top">static uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/de8/group__atomic.html#ga3d594a57773416b5a9c91d46fb52f904">atomic_fetch_sub_64</a> (<a class="el" href="../../df/d8a/structatomic__64.html">atomic_64</a> *ptr, uint64_t val, int order)</td></tr>
<tr class="memdesc:ga3d594a57773416b5a9c91d46fb52f904"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomically subtracts a value from an atomic uint64_t and returns the old value.  <br /></td></tr>
<tr class="separator:ga3d594a57773416b5a9c91d46fb52f904"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga454b693117a89f152f2ad12ba3466d6f" id="r_ga454b693117a89f152f2ad12ba3466d6f"><td class="memItemLeft" align="right" valign="top">static uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/de8/group__atomic.html#ga454b693117a89f152f2ad12ba3466d6f">atomic_fetch_and_64</a> (<a class="el" href="../../df/d8a/structatomic__64.html">atomic_64</a> *ptr, uint64_t val, int order)</td></tr>
<tr class="memdesc:ga454b693117a89f152f2ad12ba3466d6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomically performs a bitwise AND between an atomic uint64_t and a value, storing the result into the atomic uint64_t and returning the old value.  <br /></td></tr>
<tr class="separator:ga454b693117a89f152f2ad12ba3466d6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga91f35e7df2ebf8a342acb3719b54842e" id="r_ga91f35e7df2ebf8a342acb3719b54842e"><td class="memItemLeft" align="right" valign="top">static uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/de8/group__atomic.html#ga91f35e7df2ebf8a342acb3719b54842e">atomic_fetch_xor_64</a> (<a class="el" href="../../df/d8a/structatomic__64.html">atomic_64</a> *ptr, uint64_t val, int order)</td></tr>
<tr class="memdesc:ga91f35e7df2ebf8a342acb3719b54842e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomically performs a bitwise XOR between an atomic uint64_t and a value, storing the result into the atomic uint64_t and returning the old value.  <br /></td></tr>
<tr class="separator:ga91f35e7df2ebf8a342acb3719b54842e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0c4e81e122f6913006de82718cb8c8cc" id="r_ga0c4e81e122f6913006de82718cb8c8cc"><td class="memItemLeft" align="right" valign="top">static uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/de8/group__atomic.html#ga0c4e81e122f6913006de82718cb8c8cc">atomic_fetch_or_64</a> (<a class="el" href="../../df/d8a/structatomic__64.html">atomic_64</a> *ptr, uint64_t val, int order)</td></tr>
<tr class="memdesc:ga0c4e81e122f6913006de82718cb8c8cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomically performs a bitwise OR between an atomic uint64_t and a value, storing the result into the atomic uint64_t and returning the old value.  <br /></td></tr>
<tr class="separator:ga0c4e81e122f6913006de82718cb8c8cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5e4cd643d916deba8d925dbb06819f39" id="r_ga5e4cd643d916deba8d925dbb06819f39"><td class="memItemLeft" align="right" valign="top">static uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/de8/group__atomic.html#ga5e4cd643d916deba8d925dbb06819f39">atomic_fetch_nand_64</a> (<a class="el" href="../../df/d8a/structatomic__64.html">atomic_64</a> *ptr, uint64_t val, int order)</td></tr>
<tr class="memdesc:ga5e4cd643d916deba8d925dbb06819f39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomically performs a bitwise NAND between an atomic uint64_t and a value, storing the result into the atomic uint64_t and returning the old value.  <br /></td></tr>
<tr class="separator:ga5e4cd643d916deba8d925dbb06819f39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga877a9877f96b2346d065e91eb0370848" id="r_ga877a9877f96b2346d065e91eb0370848"><td class="memItemLeft" align="right" valign="top">static uintptr_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/de8/group__atomic.html#ga877a9877f96b2346d065e91eb0370848">atomic_load_ptr</a> (<a class="el" href="../../dc/d3d/structatomic__ptr.html">atomic_ptr</a> *ptr, int order)</td></tr>
<tr class="memdesc:ga877a9877f96b2346d065e91eb0370848"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomically loads the value of an atomic pointer and returns it.  <br /></td></tr>
<tr class="separator:ga877a9877f96b2346d065e91eb0370848"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeed40339978572d732a2aacfed0bf998" id="r_gaeed40339978572d732a2aacfed0bf998"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/de8/group__atomic.html#gaeed40339978572d732a2aacfed0bf998">atomic_store_ptr</a> (<a class="el" href="../../dc/d3d/structatomic__ptr.html">atomic_ptr</a> *ptr, uintptr_t val, int order)</td></tr>
<tr class="memdesc:gaeed40339978572d732a2aacfed0bf998"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomically stores a value into an atomic pointer.  <br /></td></tr>
<tr class="separator:gaeed40339978572d732a2aacfed0bf998"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae803d2ca1d7801e0ecb0ea4c0f1ad708" id="r_gae803d2ca1d7801e0ecb0ea4c0f1ad708"><td class="memItemLeft" align="right" valign="top">static uintptr_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/de8/group__atomic.html#gae803d2ca1d7801e0ecb0ea4c0f1ad708">atomic_exchange_ptr</a> (<a class="el" href="../../dc/d3d/structatomic__ptr.html">atomic_ptr</a> *ptr, uintptr_t val, int order)</td></tr>
<tr class="memdesc:gae803d2ca1d7801e0ecb0ea4c0f1ad708"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomically stores a value into an atomic pointer and returns the old value.  <br /></td></tr>
<tr class="separator:gae803d2ca1d7801e0ecb0ea4c0f1ad708"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf9398160c00ff5c2085d19f477f4de6c" id="r_gaf9398160c00ff5c2085d19f477f4de6c"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/de8/group__atomic.html#gaf9398160c00ff5c2085d19f477f4de6c">atomic_compare_exchange_ptr</a> (<a class="el" href="../../dc/d3d/structatomic__ptr.html">atomic_ptr</a> *ptr, uintptr_t *expected, uintptr_t desired, int success_order, int failure_order)</td></tr>
<tr class="memdesc:gaf9398160c00ff5c2085d19f477f4de6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomically compares the value of an atomic pointer with an expected value and, if they are equal, replaces it with a desired value.  <br /></td></tr>
<tr class="separator:gaf9398160c00ff5c2085d19f477f4de6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6d246b45782f13f2ba9a6700cd0d379b" id="r_ga6d246b45782f13f2ba9a6700cd0d379b"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/de8/group__atomic.html#ga6d246b45782f13f2ba9a6700cd0d379b">atomic_load_bool</a> (<a class="el" href="../../db/d98/structatomic__bool.html">atomic_bool</a> *ptr, int order)</td></tr>
<tr class="memdesc:ga6d246b45782f13f2ba9a6700cd0d379b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomically loads the value of an atomic boolean and returns it.  <br /></td></tr>
<tr class="separator:ga6d246b45782f13f2ba9a6700cd0d379b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga83d1a2e05a01e6692f1269fc3cc675a2" id="r_ga83d1a2e05a01e6692f1269fc3cc675a2"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/de8/group__atomic.html#ga83d1a2e05a01e6692f1269fc3cc675a2">atomic_store_bool</a> (<a class="el" href="../../db/d98/structatomic__bool.html">atomic_bool</a> *ptr, bool val, int order)</td></tr>
<tr class="memdesc:ga83d1a2e05a01e6692f1269fc3cc675a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomically stores a value into an atomic boolean.  <br /></td></tr>
<tr class="separator:ga83d1a2e05a01e6692f1269fc3cc675a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga07ddc247925246c92d5c4f771aee17be" id="r_ga07ddc247925246c92d5c4f771aee17be"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/de8/group__atomic.html#ga07ddc247925246c92d5c4f771aee17be">atomic_exchange_bool</a> (<a class="el" href="../../db/d98/structatomic__bool.html">atomic_bool</a> *ptr, bool val, int order)</td></tr>
<tr class="memdesc:ga07ddc247925246c92d5c4f771aee17be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomically stores a value into an atomic boolean and returns the old value.  <br /></td></tr>
<tr class="separator:ga07ddc247925246c92d5c4f771aee17be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5c07f97a9bd32b59bebbb532eedd0d02" id="r_ga5c07f97a9bd32b59bebbb532eedd0d02"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/de8/group__atomic.html#ga5c07f97a9bd32b59bebbb532eedd0d02">atomic_compare_exchange_bool</a> (<a class="el" href="../../db/d98/structatomic__bool.html">atomic_bool</a> *ptr, bool *expected, bool desired, int success_order, int failure_order)</td></tr>
<tr class="memdesc:ga5c07f97a9bd32b59bebbb532eedd0d02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomically compares the value of an atomic bool with an expected value and, if they are equal, replaces it with a desired value.  <br /></td></tr>
<tr class="separator:ga5c07f97a9bd32b59bebbb532eedd0d02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga84897bb8477b0f4e9996071896be47ce" id="r_ga84897bb8477b0f4e9996071896be47ce"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/de8/group__atomic.html#ga84897bb8477b0f4e9996071896be47ce">atomic_test_and_set</a> (<a class="el" href="../../db/d98/structatomic__bool.html">atomic_bool</a> *ptr, int order)</td></tr>
<tr class="memdesc:ga84897bb8477b0f4e9996071896be47ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomically sets an atomic boolean and returns the old value.  <br /></td></tr>
<tr class="separator:ga84897bb8477b0f4e9996071896be47ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6f413d53386d6134c94ec483aa4bf5c7" id="r_ga6f413d53386d6134c94ec483aa4bf5c7"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/de8/group__atomic.html#ga6f413d53386d6134c94ec483aa4bf5c7">atomic_clear</a> (<a class="el" href="../../db/d98/structatomic__bool.html">atomic_bool</a> *ptr, int order)</td></tr>
<tr class="memdesc:ga6f413d53386d6134c94ec483aa4bf5c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomically clears an atomic boolean.  <br /></td></tr>
<tr class="separator:ga6f413d53386d6134c94ec483aa4bf5c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf9cc7332f27e6373097d1b8093be299f" id="r_gaf9cc7332f27e6373097d1b8093be299f"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/de8/group__atomic.html#gaf9cc7332f27e6373097d1b8093be299f">atomic_thread_fence</a> (int order)</td></tr>
<tr class="memdesc:gaf9cc7332f27e6373097d1b8093be299f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Establishes a memory fence between threads.  <br /></td></tr>
<tr class="separator:gaf9cc7332f27e6373097d1b8093be299f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafd6a0c0f5e25ec58e184c78bf6077530" id="r_gafd6a0c0f5e25ec58e184c78bf6077530"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/de8/group__atomic.html#gafd6a0c0f5e25ec58e184c78bf6077530">atomic_signal_fence</a> (int order)</td></tr>
<tr class="memdesc:gafd6a0c0f5e25ec58e184c78bf6077530"><td class="mdescLeft">&#160;</td><td class="mdescRight">Establishes a memory fence with respect to signal handlers.  <br /></td></tr>
<tr class="separator:gafd6a0c0f5e25ec58e184c78bf6077530"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Low-level atomic types and operations. </p>
<p>This header provides lightweight atomic wrapper types.</p>
<p>These atomics provide a lightweight interface and do not implement the full C11 <code>&lt;stdatomic.h&gt;</code> API.</p>
<dl class="section note"><dt>Note</dt><dd>All atomic objects must be naturally aligned. </dd>
<dd>
Atomic operations may or may not be lock-free depending on the platform and type. Use <a class="el" href="../../d3/de8/group__atomic.html#gaa2ad8d7ede74b9c5860cd4628cc2b355">atomic_is_lock_free()</a> to determine if a type is lock free. </dd></dl>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="ga4469771b4363d1d81287967e30453e44" name="ga4469771b4363d1d81287967e30453e44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4469771b4363d1d81287967e30453e44">&#9670;&#160;</a></span>atomic_always_lock_free</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define atomic_always_lock_free</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ptr</td><td>)</td>
          <td>&#160;&#160;&#160;__atomic_always_lock_free(sizeof(*(ptr)), ptr)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Indicates whether atomic operations on the given type are always lock-free. </p>
<p>This macro evaluates to a compile-time constant expression.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>Pointer to an instance of the atomic data type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if operations are always lock-free, false otherwise. </dd></dl>

</div>
</div>
<a id="ga7b208150b120d2cc41ace2441560fb67" name="ga7b208150b120d2cc41ace2441560fb67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7b208150b120d2cc41ace2441560fb67">&#9670;&#160;</a></span>ATOMIC_INIT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ATOMIC_INIT</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">value</td><td>)</td>
          <td>&#160;&#160;&#160;{ ._atomic = value }</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Static initializer for atomic objects. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>Initial value of the atomic object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaa2ad8d7ede74b9c5860cd4628cc2b355" name="gaa2ad8d7ede74b9c5860cd4628cc2b355"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa2ad8d7ede74b9c5860cd4628cc2b355">&#9670;&#160;</a></span>atomic_is_lock_free</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define atomic_is_lock_free</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ptr</td><td>)</td>
          <td>&#160;&#160;&#160;__atomic_is_lock_free(sizeof(*(ptr)), ptr)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Indicates whether atomic operations on the given object are lock-free. </p>
<p>The result may depend on runtime properties such as object alignment or address.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>Pointer to an instance of the atomic data type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if operations are lock-free, false otherwise. </dd></dl>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="ga0411cd49bb5b71852cecd93bcbf0ca2d" name="ga0411cd49bb5b71852cecd93bcbf0ca2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0411cd49bb5b71852cecd93bcbf0ca2d">&#9670;&#160;</a></span>anonymous enum</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Memory ordering constraints for atomic operations. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga0411cd49bb5b71852cecd93bcbf0ca2daa5df71bfeb8f16c508776c55e613ca86" name="gga0411cd49bb5b71852cecd93bcbf0ca2daa5df71bfeb8f16c508776c55e613ca86"></a>ATOMIC_RELAXED&#160;</td><td class="fielddoc"><p>Provides atomicity with no ordering or synchronization guarantees. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga0411cd49bb5b71852cecd93bcbf0ca2da3c9cb31f4d7c87eb9cefc73f6170587c" name="gga0411cd49bb5b71852cecd93bcbf0ca2da3c9cb31f4d7c87eb9cefc73f6170587c"></a>ATOMIC_ACQUIRE&#160;</td><td class="fielddoc"><p>Prevents later memory operations from moving before the atomic operation. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga0411cd49bb5b71852cecd93bcbf0ca2da2b107cf2c6dce64b5e987cd0d4b4f8d3" name="gga0411cd49bb5b71852cecd93bcbf0ca2da2b107cf2c6dce64b5e987cd0d4b4f8d3"></a>ATOMIC_RELEASE&#160;</td><td class="fielddoc"><p>Prevents earlier memory operations from moving after the atomic operation. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga0411cd49bb5b71852cecd93bcbf0ca2da64012698a77715fca7ec6e2724d7bf5e" name="gga0411cd49bb5b71852cecd93bcbf0ca2da64012698a77715fca7ec6e2724d7bf5e"></a>ATOMIC_ACQ_REL&#160;</td><td class="fielddoc"><p>Combines <a class="el" href="../../d3/de8/group__atomic.html#gga0411cd49bb5b71852cecd93bcbf0ca2da3c9cb31f4d7c87eb9cefc73f6170587c">ATOMIC_ACQUIRE</a> and <a class="el" href="../../d3/de8/group__atomic.html#gga0411cd49bb5b71852cecd93bcbf0ca2da2b107cf2c6dce64b5e987cd0d4b4f8d3">ATOMIC_RELEASE</a> semantics. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga0411cd49bb5b71852cecd93bcbf0ca2da388308897863e62b26231a119b5020bc" name="gga0411cd49bb5b71852cecd93bcbf0ca2da388308897863e62b26231a119b5020bc"></a>ATOMIC_SEQ_CST&#160;</td><td class="fielddoc"><p>All threads appear to execute atomics in the same sequence. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga38b33b65d5a85491bbbd97f555db9649" name="ga38b33b65d5a85491bbbd97f555db9649"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga38b33b65d5a85491bbbd97f555db9649">&#9670;&#160;</a></span>atomic_add_fetch_32()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint32_t atomic_add_fetch_32 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../dc/d44/structatomic__32.html">atomic_32</a> *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>order</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Atomically adds a value to an atomic uint32_t and returns the new value. </p>
<p>All memory orderings are valid.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>Pointer to the atomic uint32_t. </td></tr>
    <tr><td class="paramname">val</td><td>The value to add. </td></tr>
    <tr><td class="paramname">order</td><td>Memory ordering constraint. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new value after addition. </dd></dl>

</div>
</div>
<a id="gae792ada5ceb73c7b77a02642675fcf1e" name="gae792ada5ceb73c7b77a02642675fcf1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae792ada5ceb73c7b77a02642675fcf1e">&#9670;&#160;</a></span>atomic_add_fetch_64()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint64_t atomic_add_fetch_64 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../df/d8a/structatomic__64.html">atomic_64</a> *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>order</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Atomically adds a value to an atomic uint64_t and returns the new value. </p>
<p>All memory orderings are valid.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>Pointer to the atomic uint64_t. </td></tr>
    <tr><td class="paramname">val</td><td>The value to add. </td></tr>
    <tr><td class="paramname">order</td><td>Memory ordering constraint. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new value after addition. </dd></dl>

</div>
</div>
<a id="ga01b53f8e08eb42b75d044826a2923fe8" name="ga01b53f8e08eb42b75d044826a2923fe8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga01b53f8e08eb42b75d044826a2923fe8">&#9670;&#160;</a></span>atomic_add_fetch_int()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int atomic_add_fetch_int </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../db/d09/structatomic__int.html">atomic_int</a> *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>order</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Atomically adds a value to an atomic integer and returns the new value. </p>
<p>All memory orderings are valid.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>Pointer to the atomic integer. </td></tr>
    <tr><td class="paramname">val</td><td>The value to add. </td></tr>
    <tr><td class="paramname">order</td><td>Memory ordering constraint. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new value after addition. </dd></dl>

</div>
</div>
<a id="ga4dfeede756859ad30ac13f5848c454ce" name="ga4dfeede756859ad30ac13f5848c454ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4dfeede756859ad30ac13f5848c454ce">&#9670;&#160;</a></span>atomic_and_fetch_32()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint32_t atomic_and_fetch_32 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../dc/d44/structatomic__32.html">atomic_32</a> *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>order</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Atomically performs a bitwise AND between an atomic uint32_t and a value, storing the result into the atomic uint32_t and returning it. </p>
<p>All memory orderings are valid.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>Pointer to the atomic uint32_t. </td></tr>
    <tr><td class="paramname">val</td><td>The value to AND with. </td></tr>
    <tr><td class="paramname">order</td><td>Memory ordering constraint. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new value after the AND operation. </dd></dl>

</div>
</div>
<a id="gaa11a79c0b15a2d72da0be0083311cee7" name="gaa11a79c0b15a2d72da0be0083311cee7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa11a79c0b15a2d72da0be0083311cee7">&#9670;&#160;</a></span>atomic_and_fetch_64()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint64_t atomic_and_fetch_64 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../df/d8a/structatomic__64.html">atomic_64</a> *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>order</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Atomically performs a bitwise AND between an atomic uint64_t and a value, storing the result into the atomic uint64_t and returning it. </p>
<p>All memory orderings are valid.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>Pointer to the atomic uint64_t. </td></tr>
    <tr><td class="paramname">val</td><td>The value to AND with. </td></tr>
    <tr><td class="paramname">order</td><td>Memory ordering constraint. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new value after the AND operation. </dd></dl>

</div>
</div>
<a id="ga01f12416cf4caf8524ce89a55f0f25c9" name="ga01f12416cf4caf8524ce89a55f0f25c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga01f12416cf4caf8524ce89a55f0f25c9">&#9670;&#160;</a></span>atomic_and_fetch_int()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int atomic_and_fetch_int </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../db/d09/structatomic__int.html">atomic_int</a> *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>order</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Atomically performs a bitwise AND between an atomic integer and a value, storing the result into the atomic integer and returning it. </p>
<p>All memory orderings are valid.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>Pointer to the atomic integer. </td></tr>
    <tr><td class="paramname">val</td><td>The value to AND with. </td></tr>
    <tr><td class="paramname">order</td><td>Memory ordering constraint. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new value after the AND operation. </dd></dl>

</div>
</div>
<a id="ga6f413d53386d6134c94ec483aa4bf5c7" name="ga6f413d53386d6134c94ec483aa4bf5c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6f413d53386d6134c94ec483aa4bf5c7">&#9670;&#160;</a></span>atomic_clear()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void atomic_clear </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../db/d98/structatomic__bool.html">atomic_bool</a> *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>order</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Atomically clears an atomic boolean. </p>
<p>Valid memory orderings are:</p><ul>
<li><a class="el" href="../../d3/de8/group__atomic.html#gga0411cd49bb5b71852cecd93bcbf0ca2daa5df71bfeb8f16c508776c55e613ca86">ATOMIC_RELAXED</a></li>
<li><a class="el" href="../../d3/de8/group__atomic.html#gga0411cd49bb5b71852cecd93bcbf0ca2da2b107cf2c6dce64b5e987cd0d4b4f8d3">ATOMIC_RELEASE</a></li>
<li><a class="el" href="../../d3/de8/group__atomic.html#gga0411cd49bb5b71852cecd93bcbf0ca2da388308897863e62b26231a119b5020bc">ATOMIC_SEQ_CST</a></li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>Pointer to the atomic boolean. </td></tr>
    <tr><td class="paramname">order</td><td>Memory ordering constraint. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga6c3434dce8a4b5abf22ca26374ddfba6" name="ga6c3434dce8a4b5abf22ca26374ddfba6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6c3434dce8a4b5abf22ca26374ddfba6">&#9670;&#160;</a></span>atomic_compare_exchange_32()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool atomic_compare_exchange_32 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../dc/d44/structatomic__32.html">atomic_32</a> *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>expected</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>desired</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>success_order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>failure_order</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Atomically compares the value of an atomic uint32_t with an expected value and, if they are equal, replaces it with a desired value. </p>
<p>All memory orderings are valid for <code>success_order</code>.</p>
<p>Valid memory orderings for <code>failure_order</code> are:</p><ul>
<li><a class="el" href="../../d3/de8/group__atomic.html#gga0411cd49bb5b71852cecd93bcbf0ca2daa5df71bfeb8f16c508776c55e613ca86">ATOMIC_RELAXED</a></li>
<li><a class="el" href="../../d3/de8/group__atomic.html#gga0411cd49bb5b71852cecd93bcbf0ca2da3c9cb31f4d7c87eb9cefc73f6170587c">ATOMIC_ACQUIRE</a></li>
<li><a class="el" href="../../d3/de8/group__atomic.html#gga0411cd49bb5b71852cecd93bcbf0ca2da388308897863e62b26231a119b5020bc">ATOMIC_SEQ_CST</a></li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>Pointer to the atomic uint32_t. </td></tr>
    <tr><td class="paramname">expected</td><td>Pointer to the expected value. If the comparison fails, this value is updated with the current value of the atomic uint32_t. </td></tr>
    <tr><td class="paramname">desired</td><td>The value to store if the comparison succeeds. </td></tr>
    <tr><td class="paramname">success_order</td><td>Memory ordering constraint if the exchange is successful. </td></tr>
    <tr><td class="paramname">failure_order</td><td>Memory ordering constraint if the exchange fails. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the exchange was performed, false otherwise. </dd></dl>

</div>
</div>
<a id="ga50163a1d7c1891feb8902c332c37304b" name="ga50163a1d7c1891feb8902c332c37304b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga50163a1d7c1891feb8902c332c37304b">&#9670;&#160;</a></span>atomic_compare_exchange_64()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool atomic_compare_exchange_64 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../df/d8a/structatomic__64.html">atomic_64</a> *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>expected</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>desired</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>success_order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>failure_order</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Atomically compares the value of an atomic uint64_t with an expected value and, if they are equal, replaces it with a desired value. </p>
<p>All memory orderings are valid for <code>success_order</code>.</p>
<p>Valid memory orderings for <code>failure_order</code> are:</p><ul>
<li><a class="el" href="../../d3/de8/group__atomic.html#gga0411cd49bb5b71852cecd93bcbf0ca2daa5df71bfeb8f16c508776c55e613ca86">ATOMIC_RELAXED</a></li>
<li><a class="el" href="../../d3/de8/group__atomic.html#gga0411cd49bb5b71852cecd93bcbf0ca2da3c9cb31f4d7c87eb9cefc73f6170587c">ATOMIC_ACQUIRE</a></li>
<li><a class="el" href="../../d3/de8/group__atomic.html#gga0411cd49bb5b71852cecd93bcbf0ca2da388308897863e62b26231a119b5020bc">ATOMIC_SEQ_CST</a></li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>Pointer to the atomic uint64_t. </td></tr>
    <tr><td class="paramname">expected</td><td>Pointer to the expected value. If the comparison fails, this value is updated with the current value of the atomic uint64_t. </td></tr>
    <tr><td class="paramname">desired</td><td>The value to store if the comparison succeeds. </td></tr>
    <tr><td class="paramname">success_order</td><td>Memory ordering constraint if the exchange is successful. </td></tr>
    <tr><td class="paramname">failure_order</td><td>Memory ordering constraint if the exchange fails. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the exchange was performed, false otherwise. </dd></dl>

</div>
</div>
<a id="ga5c07f97a9bd32b59bebbb532eedd0d02" name="ga5c07f97a9bd32b59bebbb532eedd0d02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5c07f97a9bd32b59bebbb532eedd0d02">&#9670;&#160;</a></span>atomic_compare_exchange_bool()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool atomic_compare_exchange_bool </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../db/d98/structatomic__bool.html">atomic_bool</a> *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>expected</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>desired</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>success_order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>failure_order</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Atomically compares the value of an atomic bool with an expected value and, if they are equal, replaces it with a desired value. </p>
<p>All memory orderings are valid for <code>success_order</code>.</p>
<p>Valid memory orderings for <code>failure_order</code> are:</p><ul>
<li><a class="el" href="../../d3/de8/group__atomic.html#gga0411cd49bb5b71852cecd93bcbf0ca2daa5df71bfeb8f16c508776c55e613ca86">ATOMIC_RELAXED</a></li>
<li><a class="el" href="../../d3/de8/group__atomic.html#gga0411cd49bb5b71852cecd93bcbf0ca2da3c9cb31f4d7c87eb9cefc73f6170587c">ATOMIC_ACQUIRE</a></li>
<li><a class="el" href="../../d3/de8/group__atomic.html#gga0411cd49bb5b71852cecd93bcbf0ca2da388308897863e62b26231a119b5020bc">ATOMIC_SEQ_CST</a></li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>Pointer to the atomic bool. </td></tr>
    <tr><td class="paramname">expected</td><td>Pointer to the expected value. If the comparison fails, this value is updated with the current value of the atomic bool. </td></tr>
    <tr><td class="paramname">desired</td><td>The value to store if the comparison succeeds. </td></tr>
    <tr><td class="paramname">success_order</td><td>Memory ordering constraint if the exchange is successful. </td></tr>
    <tr><td class="paramname">failure_order</td><td>Memory ordering constraint if the exchange fails. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the exchange was performed, false otherwise. </dd></dl>

</div>
</div>
<a id="ga431b27ed78f204d45a9f565c801e8151" name="ga431b27ed78f204d45a9f565c801e8151"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga431b27ed78f204d45a9f565c801e8151">&#9670;&#160;</a></span>atomic_compare_exchange_int()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool atomic_compare_exchange_int </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../db/d09/structatomic__int.html">atomic_int</a> *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>expected</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>desired</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>success_order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>failure_order</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Atomically compares the value of an atomic integer with an expected value and, if they are equal, replaces it with a desired value. </p>
<p>All memory orderings are valid for <code>success_order</code>.</p>
<p>Valid memory orderings for <code>failure_order</code> are:</p><ul>
<li><a class="el" href="../../d3/de8/group__atomic.html#gga0411cd49bb5b71852cecd93bcbf0ca2daa5df71bfeb8f16c508776c55e613ca86">ATOMIC_RELAXED</a></li>
<li><a class="el" href="../../d3/de8/group__atomic.html#gga0411cd49bb5b71852cecd93bcbf0ca2da3c9cb31f4d7c87eb9cefc73f6170587c">ATOMIC_ACQUIRE</a></li>
<li><a class="el" href="../../d3/de8/group__atomic.html#gga0411cd49bb5b71852cecd93bcbf0ca2da388308897863e62b26231a119b5020bc">ATOMIC_SEQ_CST</a></li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>Pointer to the atomic integer. </td></tr>
    <tr><td class="paramname">expected</td><td>Pointer to the expected value. If the comparison fails, this value is updated with the current value of the atomic integer. </td></tr>
    <tr><td class="paramname">desired</td><td>The value to store if the comparison succeeds. </td></tr>
    <tr><td class="paramname">success_order</td><td>Memory ordering constraint if the exchange is successful. </td></tr>
    <tr><td class="paramname">failure_order</td><td>Memory ordering constraint if the exchange fails. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the exchange was performed, false otherwise. </dd></dl>

</div>
</div>
<a id="gaf9398160c00ff5c2085d19f477f4de6c" name="gaf9398160c00ff5c2085d19f477f4de6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf9398160c00ff5c2085d19f477f4de6c">&#9670;&#160;</a></span>atomic_compare_exchange_ptr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool atomic_compare_exchange_ptr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../dc/d3d/structatomic__ptr.html">atomic_ptr</a> *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uintptr_t *&#160;</td>
          <td class="paramname"><em>expected</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uintptr_t&#160;</td>
          <td class="paramname"><em>desired</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>success_order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>failure_order</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Atomically compares the value of an atomic pointer with an expected value and, if they are equal, replaces it with a desired value. </p>
<p>All memory orderings are valid for <code>success_order</code>.</p>
<p>Valid memory orderings for <code>failure_order</code> are:</p><ul>
<li><a class="el" href="../../d3/de8/group__atomic.html#gga0411cd49bb5b71852cecd93bcbf0ca2daa5df71bfeb8f16c508776c55e613ca86">ATOMIC_RELAXED</a></li>
<li><a class="el" href="../../d3/de8/group__atomic.html#gga0411cd49bb5b71852cecd93bcbf0ca2da3c9cb31f4d7c87eb9cefc73f6170587c">ATOMIC_ACQUIRE</a></li>
<li><a class="el" href="../../d3/de8/group__atomic.html#gga0411cd49bb5b71852cecd93bcbf0ca2da388308897863e62b26231a119b5020bc">ATOMIC_SEQ_CST</a></li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>Pointer to the atomic pointer. </td></tr>
    <tr><td class="paramname">expected</td><td>Pointer to the expected value. If the comparison fails, this value is updated with the current value of the atomic pointer. </td></tr>
    <tr><td class="paramname">desired</td><td>The value to store if the comparison succeeds. </td></tr>
    <tr><td class="paramname">success_order</td><td>Memory ordering constraint if the exchange is successful. </td></tr>
    <tr><td class="paramname">failure_order</td><td>Memory ordering constraint if the exchange fails. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the exchange was performed, false otherwise. </dd></dl>

</div>
</div>
<a id="gaf0b172c9df42030baeb6f7b81ba8249a" name="gaf0b172c9df42030baeb6f7b81ba8249a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf0b172c9df42030baeb6f7b81ba8249a">&#9670;&#160;</a></span>atomic_exchange_32()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint32_t atomic_exchange_32 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../dc/d44/structatomic__32.html">atomic_32</a> *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>order</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Atomically stores a value into an atomic uint32_t and returns the old value. </p>
<p>All memory orderings are valid.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>Pointer to the atomic uint32_t. </td></tr>
    <tr><td class="paramname">val</td><td>The value to store. </td></tr>
    <tr><td class="paramname">order</td><td>Memory ordering constraint. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The old value of the atomic uint32_t. </dd></dl>

</div>
</div>
<a id="ga261933ebaa9e4515aa6d160458115129" name="ga261933ebaa9e4515aa6d160458115129"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga261933ebaa9e4515aa6d160458115129">&#9670;&#160;</a></span>atomic_exchange_64()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint64_t atomic_exchange_64 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../df/d8a/structatomic__64.html">atomic_64</a> *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>order</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Atomically stores a value into an atomic uint64_t and returns the old value. </p>
<p>All memory orderings are valid.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>Pointer to the atomic uint64_t. </td></tr>
    <tr><td class="paramname">val</td><td>The value to store. </td></tr>
    <tr><td class="paramname">order</td><td>Memory ordering constraint. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The old value of the atomic uint64_t. </dd></dl>

</div>
</div>
<a id="ga07ddc247925246c92d5c4f771aee17be" name="ga07ddc247925246c92d5c4f771aee17be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga07ddc247925246c92d5c4f771aee17be">&#9670;&#160;</a></span>atomic_exchange_bool()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool atomic_exchange_bool </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../db/d98/structatomic__bool.html">atomic_bool</a> *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>order</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Atomically stores a value into an atomic boolean and returns the old value. </p>
<p>All memory orderings are valid.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>Pointer to the atomic boolean. </td></tr>
    <tr><td class="paramname">val</td><td>The value to store. </td></tr>
    <tr><td class="paramname">order</td><td>Memory ordering constraint. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The old value of the atomic boolean. </dd></dl>

</div>
</div>
<a id="ga54d4e5749dce93db16225efe211b964a" name="ga54d4e5749dce93db16225efe211b964a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga54d4e5749dce93db16225efe211b964a">&#9670;&#160;</a></span>atomic_exchange_int()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int atomic_exchange_int </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../db/d09/structatomic__int.html">atomic_int</a> *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>order</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Atomically stores a value into an atomic integer and returns the old value. </p>
<p>All memory orderings are valid.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>Pointer to the atomic integer. </td></tr>
    <tr><td class="paramname">val</td><td>The value to store. </td></tr>
    <tr><td class="paramname">order</td><td>Memory ordering constraint. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The old value of the atomic integer. </dd></dl>

</div>
</div>
<a id="gae803d2ca1d7801e0ecb0ea4c0f1ad708" name="gae803d2ca1d7801e0ecb0ea4c0f1ad708"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae803d2ca1d7801e0ecb0ea4c0f1ad708">&#9670;&#160;</a></span>atomic_exchange_ptr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uintptr_t atomic_exchange_ptr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../dc/d3d/structatomic__ptr.html">atomic_ptr</a> *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uintptr_t&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>order</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Atomically stores a value into an atomic pointer and returns the old value. </p>
<p>All memory orderings are valid.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>Pointer to the atomic pointer. </td></tr>
    <tr><td class="paramname">val</td><td>The value to store. </td></tr>
    <tr><td class="paramname">order</td><td>Memory ordering constraint. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The old value of the atomic pointer. </dd></dl>

</div>
</div>
<a id="ga187929c3a34e71e3f9d2befdacf2cc49" name="ga187929c3a34e71e3f9d2befdacf2cc49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga187929c3a34e71e3f9d2befdacf2cc49">&#9670;&#160;</a></span>atomic_fetch_add_32()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint32_t atomic_fetch_add_32 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../dc/d44/structatomic__32.html">atomic_32</a> *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>order</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Atomically adds a value to an atomic uint32_t and returns the old value. </p>
<p>All memory orderings are valid.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>Pointer to the atomic uint32_t. </td></tr>
    <tr><td class="paramname">val</td><td>The value to add. </td></tr>
    <tr><td class="paramname">order</td><td>Memory ordering constraint. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The old value of the atomic uint32_t. </dd></dl>

</div>
</div>
<a id="ga55d72381175d559619ace69704671e3e" name="ga55d72381175d559619ace69704671e3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga55d72381175d559619ace69704671e3e">&#9670;&#160;</a></span>atomic_fetch_add_64()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint64_t atomic_fetch_add_64 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../df/d8a/structatomic__64.html">atomic_64</a> *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>order</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Atomically adds a value to an atomic uint64_t and returns the old value. </p>
<p>All memory orderings are valid.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>Pointer to the atomic uint64_t. </td></tr>
    <tr><td class="paramname">val</td><td>The value to add. </td></tr>
    <tr><td class="paramname">order</td><td>Memory ordering constraint. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The old value of the atomic uint64_t. </dd></dl>

</div>
</div>
<a id="gaff0de9ccfd4c10e7230e5ae0acb0f3f3" name="gaff0de9ccfd4c10e7230e5ae0acb0f3f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaff0de9ccfd4c10e7230e5ae0acb0f3f3">&#9670;&#160;</a></span>atomic_fetch_add_int()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int atomic_fetch_add_int </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../db/d09/structatomic__int.html">atomic_int</a> *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>order</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Atomically adds a value to an atomic integer and returns the old value. </p>
<p>All memory orderings are valid.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>Pointer to the atomic integer. </td></tr>
    <tr><td class="paramname">val</td><td>The value to add. </td></tr>
    <tr><td class="paramname">order</td><td>Memory ordering constraint. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The old value of the atomic integer. </dd></dl>

</div>
</div>
<a id="ga5e14080babc394daa3070ea86360657a" name="ga5e14080babc394daa3070ea86360657a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5e14080babc394daa3070ea86360657a">&#9670;&#160;</a></span>atomic_fetch_and_32()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint32_t atomic_fetch_and_32 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../dc/d44/structatomic__32.html">atomic_32</a> *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>order</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Atomically performs a bitwise AND between an atomic uint32_t and a value, storing the result into the atomic uint32_t and returning the old value. </p>
<p>All memory orderings are valid.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>Pointer to the atomic uint32_t. </td></tr>
    <tr><td class="paramname">val</td><td>The value to AND with. </td></tr>
    <tr><td class="paramname">order</td><td>Memory ordering constraint. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The old value of the atomic uint32_t. </dd></dl>

</div>
</div>
<a id="ga454b693117a89f152f2ad12ba3466d6f" name="ga454b693117a89f152f2ad12ba3466d6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga454b693117a89f152f2ad12ba3466d6f">&#9670;&#160;</a></span>atomic_fetch_and_64()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint64_t atomic_fetch_and_64 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../df/d8a/structatomic__64.html">atomic_64</a> *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>order</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Atomically performs a bitwise AND between an atomic uint64_t and a value, storing the result into the atomic uint64_t and returning the old value. </p>
<p>All memory orderings are valid.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>Pointer to the atomic uint64_t. </td></tr>
    <tr><td class="paramname">val</td><td>The value to AND with. </td></tr>
    <tr><td class="paramname">order</td><td>Memory ordering constraint. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The old value of the atomic uint64_t. </dd></dl>

</div>
</div>
<a id="ga0fe797f4715a91f026c9ccf20bcad80e" name="ga0fe797f4715a91f026c9ccf20bcad80e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0fe797f4715a91f026c9ccf20bcad80e">&#9670;&#160;</a></span>atomic_fetch_and_int()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int atomic_fetch_and_int </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../db/d09/structatomic__int.html">atomic_int</a> *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>order</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Atomically performs a bitwise AND between an atomic integer and a value, storing the result into the atomic integer and returning the old value. </p>
<p>All memory orderings are valid.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>Pointer to the atomic integer. </td></tr>
    <tr><td class="paramname">val</td><td>The value to AND with. </td></tr>
    <tr><td class="paramname">order</td><td>Memory ordering constraint. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The old value of the atomic integer. </dd></dl>

</div>
</div>
<a id="ga23238a31680d46978f6e16497c49a831" name="ga23238a31680d46978f6e16497c49a831"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga23238a31680d46978f6e16497c49a831">&#9670;&#160;</a></span>atomic_fetch_nand_32()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint32_t atomic_fetch_nand_32 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../dc/d44/structatomic__32.html">atomic_32</a> *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>order</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Atomically performs a bitwise NAND between an atomic uint32_t and a value, storing the result into the atomic uint32_t and returning the old value. </p>
<p>All memory orderings are valid.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>Pointer to the atomic uint32_t. </td></tr>
    <tr><td class="paramname">val</td><td>The value to NAND with. </td></tr>
    <tr><td class="paramname">order</td><td>Memory ordering constraint. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The old value of the atomic uint32_t. </dd></dl>

</div>
</div>
<a id="ga5e4cd643d916deba8d925dbb06819f39" name="ga5e4cd643d916deba8d925dbb06819f39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5e4cd643d916deba8d925dbb06819f39">&#9670;&#160;</a></span>atomic_fetch_nand_64()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint64_t atomic_fetch_nand_64 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../df/d8a/structatomic__64.html">atomic_64</a> *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>order</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Atomically performs a bitwise NAND between an atomic uint64_t and a value, storing the result into the atomic uint64_t and returning the old value. </p>
<p>All memory orderings are valid.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>Pointer to the atomic uint64_t. </td></tr>
    <tr><td class="paramname">val</td><td>The value to NAND with. </td></tr>
    <tr><td class="paramname">order</td><td>Memory ordering constraint. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The old value of the atomic uint64_t. </dd></dl>

</div>
</div>
<a id="ga1fffc6bd0faf219c0eebaae86c511665" name="ga1fffc6bd0faf219c0eebaae86c511665"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1fffc6bd0faf219c0eebaae86c511665">&#9670;&#160;</a></span>atomic_fetch_nand_int()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int atomic_fetch_nand_int </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../db/d09/structatomic__int.html">atomic_int</a> *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>order</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Atomically performs a bitwise NAND between an atomic integer and a value, storing the result into the atomic integer and returning the old value. </p>
<p>All memory orderings are valid.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>Pointer to the atomic integer. </td></tr>
    <tr><td class="paramname">val</td><td>The value to NAND with. </td></tr>
    <tr><td class="paramname">order</td><td>Memory ordering constraint. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The old value of the atomic integer. </dd></dl>

</div>
</div>
<a id="ga648b3777d353f9b55093978c38964612" name="ga648b3777d353f9b55093978c38964612"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga648b3777d353f9b55093978c38964612">&#9670;&#160;</a></span>atomic_fetch_or_32()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint32_t atomic_fetch_or_32 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../dc/d44/structatomic__32.html">atomic_32</a> *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>order</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Atomically performs a bitwise OR between an atomic uint32_t and a value, storing the result into the atomic uint32_t and returning the old value. </p>
<p>All memory orderings are valid.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>Pointer to the atomic uint32_t. </td></tr>
    <tr><td class="paramname">val</td><td>The value to OR with. </td></tr>
    <tr><td class="paramname">order</td><td>Memory ordering constraint. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The old value of the atomic uint32_t. </dd></dl>

</div>
</div>
<a id="ga0c4e81e122f6913006de82718cb8c8cc" name="ga0c4e81e122f6913006de82718cb8c8cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0c4e81e122f6913006de82718cb8c8cc">&#9670;&#160;</a></span>atomic_fetch_or_64()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint64_t atomic_fetch_or_64 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../df/d8a/structatomic__64.html">atomic_64</a> *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>order</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Atomically performs a bitwise OR between an atomic uint64_t and a value, storing the result into the atomic uint64_t and returning the old value. </p>
<p>All memory orderings are valid.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>Pointer to the atomic uint64_t. </td></tr>
    <tr><td class="paramname">val</td><td>The value to OR with. </td></tr>
    <tr><td class="paramname">order</td><td>Memory ordering constraint. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The old value of the atomic uint64_t. </dd></dl>

</div>
</div>
<a id="gaf86cdfabf01f6b6cf2f78b3f46371d18" name="gaf86cdfabf01f6b6cf2f78b3f46371d18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf86cdfabf01f6b6cf2f78b3f46371d18">&#9670;&#160;</a></span>atomic_fetch_or_int()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int atomic_fetch_or_int </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../db/d09/structatomic__int.html">atomic_int</a> *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>order</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Atomically performs a bitwise OR between an atomic integer and a value, storing the result into the atomic integer and returning the old value. </p>
<p>All memory orderings are valid.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>Pointer to the atomic integer. </td></tr>
    <tr><td class="paramname">val</td><td>The value to OR with. </td></tr>
    <tr><td class="paramname">order</td><td>Memory ordering constraint. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The old value of the atomic integer. </dd></dl>

</div>
</div>
<a id="ga8bb107a26f061f724190df6fbe706e5c" name="ga8bb107a26f061f724190df6fbe706e5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8bb107a26f061f724190df6fbe706e5c">&#9670;&#160;</a></span>atomic_fetch_sub_32()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint32_t atomic_fetch_sub_32 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../dc/d44/structatomic__32.html">atomic_32</a> *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>order</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Atomically subtracts a value from an atomic uint32_t and returns the old value. </p>
<p>All memory orderings are valid.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>Pointer to the atomic uint32_t. </td></tr>
    <tr><td class="paramname">val</td><td>The value to subtract. </td></tr>
    <tr><td class="paramname">order</td><td>Memory ordering constraint. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The old value of the atomic uint32_t. </dd></dl>

</div>
</div>
<a id="ga3d594a57773416b5a9c91d46fb52f904" name="ga3d594a57773416b5a9c91d46fb52f904"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3d594a57773416b5a9c91d46fb52f904">&#9670;&#160;</a></span>atomic_fetch_sub_64()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint64_t atomic_fetch_sub_64 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../df/d8a/structatomic__64.html">atomic_64</a> *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>order</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Atomically subtracts a value from an atomic uint64_t and returns the old value. </p>
<p>All memory orderings are valid.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>Pointer to the atomic uint64_t. </td></tr>
    <tr><td class="paramname">val</td><td>The value to subtract. </td></tr>
    <tr><td class="paramname">order</td><td>Memory ordering constraint. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The old value of the atomic uint64_t. </dd></dl>

</div>
</div>
<a id="ga7ba417c1216dae3d9fb2baedaa066344" name="ga7ba417c1216dae3d9fb2baedaa066344"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7ba417c1216dae3d9fb2baedaa066344">&#9670;&#160;</a></span>atomic_fetch_sub_int()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int atomic_fetch_sub_int </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../db/d09/structatomic__int.html">atomic_int</a> *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>order</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Atomically subtracts a value from an atomic integer and returns the old value. </p>
<p>All memory orderings are valid.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>Pointer to the atomic integer. </td></tr>
    <tr><td class="paramname">val</td><td>The value to subtract. </td></tr>
    <tr><td class="paramname">order</td><td>Memory ordering constraint. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The old value of the atomic integer. </dd></dl>

</div>
</div>
<a id="ga49f8a8c9ce9c486fdc43f145446a0fbc" name="ga49f8a8c9ce9c486fdc43f145446a0fbc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga49f8a8c9ce9c486fdc43f145446a0fbc">&#9670;&#160;</a></span>atomic_fetch_xor_32()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint32_t atomic_fetch_xor_32 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../dc/d44/structatomic__32.html">atomic_32</a> *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>order</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Atomically performs a bitwise XOR between an atomic uint32_t and a value, storing the result into the atomic uint32_t and returning the old value. </p>
<p>All memory orderings are valid.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>Pointer to the atomic uint32_t. </td></tr>
    <tr><td class="paramname">val</td><td>The value to XOR with. </td></tr>
    <tr><td class="paramname">order</td><td>Memory ordering constraint. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The old value of the atomic uint32_t. </dd></dl>

</div>
</div>
<a id="ga91f35e7df2ebf8a342acb3719b54842e" name="ga91f35e7df2ebf8a342acb3719b54842e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga91f35e7df2ebf8a342acb3719b54842e">&#9670;&#160;</a></span>atomic_fetch_xor_64()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint64_t atomic_fetch_xor_64 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../df/d8a/structatomic__64.html">atomic_64</a> *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>order</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Atomically performs a bitwise XOR between an atomic uint64_t and a value, storing the result into the atomic uint64_t and returning the old value. </p>
<p>All memory orderings are valid.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>Pointer to the atomic uint64_t. </td></tr>
    <tr><td class="paramname">val</td><td>The value to XOR with. </td></tr>
    <tr><td class="paramname">order</td><td>Memory ordering constraint. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The old value of the atomic uint64_t. </dd></dl>

</div>
</div>
<a id="gadd38601cc45a12c59d59599488314aae" name="gadd38601cc45a12c59d59599488314aae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadd38601cc45a12c59d59599488314aae">&#9670;&#160;</a></span>atomic_fetch_xor_int()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int atomic_fetch_xor_int </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../db/d09/structatomic__int.html">atomic_int</a> *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>order</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Atomically performs a bitwise XOR between an atomic integer and a value, storing the result into the atomic integer and returning the old value. </p>
<p>All memory orderings are valid.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>Pointer to the atomic integer. </td></tr>
    <tr><td class="paramname">val</td><td>The value to XOR with. </td></tr>
    <tr><td class="paramname">order</td><td>Memory ordering constraint. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The old value of the atomic integer. </dd></dl>

</div>
</div>
<a id="ga6283d393417c6be988d8e3e0fa80840e" name="ga6283d393417c6be988d8e3e0fa80840e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6283d393417c6be988d8e3e0fa80840e">&#9670;&#160;</a></span>atomic_load_32()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint32_t atomic_load_32 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../dc/d44/structatomic__32.html">atomic_32</a> *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>order</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Atomically loads the value of an atomic uint32_t and returns it. </p>
<p>Valid memory orderings are:</p><ul>
<li><a class="el" href="../../d3/de8/group__atomic.html#gga0411cd49bb5b71852cecd93bcbf0ca2daa5df71bfeb8f16c508776c55e613ca86">ATOMIC_RELAXED</a></li>
<li><a class="el" href="../../d3/de8/group__atomic.html#gga0411cd49bb5b71852cecd93bcbf0ca2da3c9cb31f4d7c87eb9cefc73f6170587c">ATOMIC_ACQUIRE</a></li>
<li><a class="el" href="../../d3/de8/group__atomic.html#gga0411cd49bb5b71852cecd93bcbf0ca2da388308897863e62b26231a119b5020bc">ATOMIC_SEQ_CST</a></li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>Pointer to the atomic uint32_t. </td></tr>
    <tr><td class="paramname">order</td><td>Memory ordering constraint. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The loaded value. </dd></dl>

</div>
</div>
<a id="gaaaf0a1963bfa6d28bc8a01c0d7bcb6ed" name="gaaaf0a1963bfa6d28bc8a01c0d7bcb6ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaaf0a1963bfa6d28bc8a01c0d7bcb6ed">&#9670;&#160;</a></span>atomic_load_64()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint64_t atomic_load_64 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../df/d8a/structatomic__64.html">atomic_64</a> *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>order</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Atomically loads the value of an atomic uint64_t and returns it. </p>
<p>Valid memory orderings are:</p><ul>
<li><a class="el" href="../../d3/de8/group__atomic.html#gga0411cd49bb5b71852cecd93bcbf0ca2daa5df71bfeb8f16c508776c55e613ca86">ATOMIC_RELAXED</a></li>
<li><a class="el" href="../../d3/de8/group__atomic.html#gga0411cd49bb5b71852cecd93bcbf0ca2da3c9cb31f4d7c87eb9cefc73f6170587c">ATOMIC_ACQUIRE</a></li>
<li><a class="el" href="../../d3/de8/group__atomic.html#gga0411cd49bb5b71852cecd93bcbf0ca2da388308897863e62b26231a119b5020bc">ATOMIC_SEQ_CST</a></li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>Pointer to the atomic uint64_t. </td></tr>
    <tr><td class="paramname">order</td><td>Memory ordering constraint. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The loaded value. </dd></dl>

</div>
</div>
<a id="ga6d246b45782f13f2ba9a6700cd0d379b" name="ga6d246b45782f13f2ba9a6700cd0d379b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6d246b45782f13f2ba9a6700cd0d379b">&#9670;&#160;</a></span>atomic_load_bool()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool atomic_load_bool </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../db/d98/structatomic__bool.html">atomic_bool</a> *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>order</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Atomically loads the value of an atomic boolean and returns it. </p>
<p>Valid memory orderings are:</p><ul>
<li><a class="el" href="../../d3/de8/group__atomic.html#gga0411cd49bb5b71852cecd93bcbf0ca2daa5df71bfeb8f16c508776c55e613ca86">ATOMIC_RELAXED</a></li>
<li><a class="el" href="../../d3/de8/group__atomic.html#gga0411cd49bb5b71852cecd93bcbf0ca2da3c9cb31f4d7c87eb9cefc73f6170587c">ATOMIC_ACQUIRE</a></li>
<li><a class="el" href="../../d3/de8/group__atomic.html#gga0411cd49bb5b71852cecd93bcbf0ca2da388308897863e62b26231a119b5020bc">ATOMIC_SEQ_CST</a></li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>Pointer to the atomic boolean. </td></tr>
    <tr><td class="paramname">order</td><td>Memory ordering constraint. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The loaded value. </dd></dl>

</div>
</div>
<a id="ga84eb183e153040448c91365eff70e33a" name="ga84eb183e153040448c91365eff70e33a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga84eb183e153040448c91365eff70e33a">&#9670;&#160;</a></span>atomic_load_int()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int atomic_load_int </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../db/d09/structatomic__int.html">atomic_int</a> *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>order</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Atomically loads the value of an atomic integer and returns it. </p>
<p>Valid memory orderings are:</p><ul>
<li><a class="el" href="../../d3/de8/group__atomic.html#gga0411cd49bb5b71852cecd93bcbf0ca2daa5df71bfeb8f16c508776c55e613ca86">ATOMIC_RELAXED</a></li>
<li><a class="el" href="../../d3/de8/group__atomic.html#gga0411cd49bb5b71852cecd93bcbf0ca2da3c9cb31f4d7c87eb9cefc73f6170587c">ATOMIC_ACQUIRE</a></li>
<li><a class="el" href="../../d3/de8/group__atomic.html#gga0411cd49bb5b71852cecd93bcbf0ca2da388308897863e62b26231a119b5020bc">ATOMIC_SEQ_CST</a></li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>Pointer to the atomic integer. </td></tr>
    <tr><td class="paramname">order</td><td>Memory ordering constraint. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The loaded value. </dd></dl>

</div>
</div>
<a id="ga877a9877f96b2346d065e91eb0370848" name="ga877a9877f96b2346d065e91eb0370848"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga877a9877f96b2346d065e91eb0370848">&#9670;&#160;</a></span>atomic_load_ptr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uintptr_t atomic_load_ptr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../dc/d3d/structatomic__ptr.html">atomic_ptr</a> *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>order</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Atomically loads the value of an atomic pointer and returns it. </p>
<p>Valid memory orderings are:</p><ul>
<li><a class="el" href="../../d3/de8/group__atomic.html#gga0411cd49bb5b71852cecd93bcbf0ca2daa5df71bfeb8f16c508776c55e613ca86">ATOMIC_RELAXED</a></li>
<li><a class="el" href="../../d3/de8/group__atomic.html#gga0411cd49bb5b71852cecd93bcbf0ca2da3c9cb31f4d7c87eb9cefc73f6170587c">ATOMIC_ACQUIRE</a></li>
<li><a class="el" href="../../d3/de8/group__atomic.html#gga0411cd49bb5b71852cecd93bcbf0ca2da388308897863e62b26231a119b5020bc">ATOMIC_SEQ_CST</a></li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>Pointer to the atomic pointer. </td></tr>
    <tr><td class="paramname">order</td><td>Memory ordering constraint. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The loaded value. </dd></dl>

</div>
</div>
<a id="gadf1370191221205c583a8b475059d2d7" name="gadf1370191221205c583a8b475059d2d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadf1370191221205c583a8b475059d2d7">&#9670;&#160;</a></span>atomic_nand_fetch_32()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint32_t atomic_nand_fetch_32 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../dc/d44/structatomic__32.html">atomic_32</a> *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>order</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Atomically performs a bitwise NAND between an atomic uint32_t and a value, storing the result into the atomic uint32_t and returning it. </p>
<p>All memory orderings are valid.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>Pointer to the atomic uint32_t. </td></tr>
    <tr><td class="paramname">val</td><td>The value to NAND with. </td></tr>
    <tr><td class="paramname">order</td><td>Memory ordering constraint. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new value after the NAND operation. </dd></dl>

</div>
</div>
<a id="gaec7a37c031d8ef2b7124164d13db1efd" name="gaec7a37c031d8ef2b7124164d13db1efd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaec7a37c031d8ef2b7124164d13db1efd">&#9670;&#160;</a></span>atomic_nand_fetch_64()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint64_t atomic_nand_fetch_64 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../df/d8a/structatomic__64.html">atomic_64</a> *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>order</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Atomically performs a bitwise NAND between an atomic uint64_t and a value, storing the result into the atomic uint64_t and returning it. </p>
<p>All memory orderings are valid.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>Pointer to the atomic uint64_t. </td></tr>
    <tr><td class="paramname">val</td><td>The value to NAND with. </td></tr>
    <tr><td class="paramname">order</td><td>Memory ordering constraint. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new value after the NAND operation. </dd></dl>

</div>
</div>
<a id="ga0e44f7d96ed6f6e037ffd6b81f2f43f5" name="ga0e44f7d96ed6f6e037ffd6b81f2f43f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0e44f7d96ed6f6e037ffd6b81f2f43f5">&#9670;&#160;</a></span>atomic_nand_fetch_int()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int atomic_nand_fetch_int </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../db/d09/structatomic__int.html">atomic_int</a> *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>order</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Atomically performs a bitwise NAND between an atomic integer and a value, storing the result into the atomic integer and returning it. </p>
<p>All memory orderings are valid.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>Pointer to the atomic integer. </td></tr>
    <tr><td class="paramname">val</td><td>The value to NAND with. </td></tr>
    <tr><td class="paramname">order</td><td>Memory ordering constraint. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new value after the NAND operation. </dd></dl>

</div>
</div>
<a id="ga78e5c7c54ffb6c6f9babada13127838e" name="ga78e5c7c54ffb6c6f9babada13127838e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga78e5c7c54ffb6c6f9babada13127838e">&#9670;&#160;</a></span>atomic_or_fetch_32()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint32_t atomic_or_fetch_32 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../dc/d44/structatomic__32.html">atomic_32</a> *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>order</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Atomically performs a bitwise OR between an atomic uint32_t and a value, storing the result into the atomic uint32_t and returning it. </p>
<p>All memory orderings are valid.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>Pointer to the atomic uint32_t. </td></tr>
    <tr><td class="paramname">val</td><td>The value to OR with. </td></tr>
    <tr><td class="paramname">order</td><td>Memory ordering constraint. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new value after the OR operation. </dd></dl>

</div>
</div>
<a id="ga51e82db2349a422d1841a175fe0bfca6" name="ga51e82db2349a422d1841a175fe0bfca6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga51e82db2349a422d1841a175fe0bfca6">&#9670;&#160;</a></span>atomic_or_fetch_64()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint64_t atomic_or_fetch_64 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../df/d8a/structatomic__64.html">atomic_64</a> *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>order</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Atomically performs a bitwise OR between an atomic uint64_t and a value, storing the result into the atomic uint64_t and returning it. </p>
<p>All memory orderings are valid.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>Pointer to the atomic uint64_t. </td></tr>
    <tr><td class="paramname">val</td><td>The value to OR with. </td></tr>
    <tr><td class="paramname">order</td><td>Memory ordering constraint. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new value after the OR operation. </dd></dl>

</div>
</div>
<a id="ga9a3bea073c0fbbce302e1168b9afb02a" name="ga9a3bea073c0fbbce302e1168b9afb02a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9a3bea073c0fbbce302e1168b9afb02a">&#9670;&#160;</a></span>atomic_or_fetch_int()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int atomic_or_fetch_int </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../db/d09/structatomic__int.html">atomic_int</a> *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>order</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Atomically performs a bitwise OR between an atomic integer and a value, storing the result into the atomic integer and returning it. </p>
<p>All memory orderings are valid.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>Pointer to the atomic integer. </td></tr>
    <tr><td class="paramname">val</td><td>The value to OR with. </td></tr>
    <tr><td class="paramname">order</td><td>Memory ordering constraint. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new value after the OR operation. </dd></dl>

</div>
</div>
<a id="gafd6a0c0f5e25ec58e184c78bf6077530" name="gafd6a0c0f5e25ec58e184c78bf6077530"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafd6a0c0f5e25ec58e184c78bf6077530">&#9670;&#160;</a></span>atomic_signal_fence()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void atomic_signal_fence </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>order</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Establishes a memory fence with respect to signal handlers. </p>
<p>Prevents certain memory operations issued before the fence from being reordered with memory operations issued after the fence, according to the specified memory ordering constraint.</p>
<p>This function only affects compiler reordering with respect to signal handlers and does not emit any hardware memory barrier instructions.</p>
<p>All memory orderings are valid.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">order</td><td>Memory ordering constraint. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaa3e6ed3cffc530d86f0fcd3bb55d85c5" name="gaa3e6ed3cffc530d86f0fcd3bb55d85c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa3e6ed3cffc530d86f0fcd3bb55d85c5">&#9670;&#160;</a></span>atomic_store_32()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void atomic_store_32 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../dc/d44/structatomic__32.html">atomic_32</a> *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>order</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Atomically stores a value into an atomic uint32_t. </p>
<p>Valid memory orderings are:</p><ul>
<li><a class="el" href="../../d3/de8/group__atomic.html#gga0411cd49bb5b71852cecd93bcbf0ca2daa5df71bfeb8f16c508776c55e613ca86">ATOMIC_RELAXED</a></li>
<li><a class="el" href="../../d3/de8/group__atomic.html#gga0411cd49bb5b71852cecd93bcbf0ca2da2b107cf2c6dce64b5e987cd0d4b4f8d3">ATOMIC_RELEASE</a></li>
<li><a class="el" href="../../d3/de8/group__atomic.html#gga0411cd49bb5b71852cecd93bcbf0ca2da388308897863e62b26231a119b5020bc">ATOMIC_SEQ_CST</a></li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>Pointer to the atomic uint32_t. </td></tr>
    <tr><td class="paramname">val</td><td>The value to store. </td></tr>
    <tr><td class="paramname">order</td><td>Memory ordering constraint. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gab3c4ec522918b3bd9da1cf7f91f1d4d5" name="gab3c4ec522918b3bd9da1cf7f91f1d4d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab3c4ec522918b3bd9da1cf7f91f1d4d5">&#9670;&#160;</a></span>atomic_store_64()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void atomic_store_64 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../df/d8a/structatomic__64.html">atomic_64</a> *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>order</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Atomically stores a value into an atomic uint64_t. </p>
<p>Valid memory orderings are:</p><ul>
<li><a class="el" href="../../d3/de8/group__atomic.html#gga0411cd49bb5b71852cecd93bcbf0ca2daa5df71bfeb8f16c508776c55e613ca86">ATOMIC_RELAXED</a></li>
<li><a class="el" href="../../d3/de8/group__atomic.html#gga0411cd49bb5b71852cecd93bcbf0ca2da2b107cf2c6dce64b5e987cd0d4b4f8d3">ATOMIC_RELEASE</a></li>
<li><a class="el" href="../../d3/de8/group__atomic.html#gga0411cd49bb5b71852cecd93bcbf0ca2da388308897863e62b26231a119b5020bc">ATOMIC_SEQ_CST</a></li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>Pointer to the atomic uint64_t. </td></tr>
    <tr><td class="paramname">val</td><td>The value to store. </td></tr>
    <tr><td class="paramname">order</td><td>Memory ordering constraint. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga83d1a2e05a01e6692f1269fc3cc675a2" name="ga83d1a2e05a01e6692f1269fc3cc675a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga83d1a2e05a01e6692f1269fc3cc675a2">&#9670;&#160;</a></span>atomic_store_bool()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void atomic_store_bool </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../db/d98/structatomic__bool.html">atomic_bool</a> *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>order</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Atomically stores a value into an atomic boolean. </p>
<p>Valid memory orderings are:</p><ul>
<li><a class="el" href="../../d3/de8/group__atomic.html#gga0411cd49bb5b71852cecd93bcbf0ca2daa5df71bfeb8f16c508776c55e613ca86">ATOMIC_RELAXED</a></li>
<li><a class="el" href="../../d3/de8/group__atomic.html#gga0411cd49bb5b71852cecd93bcbf0ca2da2b107cf2c6dce64b5e987cd0d4b4f8d3">ATOMIC_RELEASE</a></li>
<li><a class="el" href="../../d3/de8/group__atomic.html#gga0411cd49bb5b71852cecd93bcbf0ca2da388308897863e62b26231a119b5020bc">ATOMIC_SEQ_CST</a></li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>Pointer to the atomic boolean. </td></tr>
    <tr><td class="paramname">val</td><td>The value to store. </td></tr>
    <tr><td class="paramname">order</td><td>Memory ordering constraint. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaafcfd70fabfbb2246d86b9ecbb45fd17" name="gaafcfd70fabfbb2246d86b9ecbb45fd17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaafcfd70fabfbb2246d86b9ecbb45fd17">&#9670;&#160;</a></span>atomic_store_int()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void atomic_store_int </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../db/d09/structatomic__int.html">atomic_int</a> *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>order</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Atomically stores a value into an atomic integer. </p>
<p>Valid memory orderings are:</p><ul>
<li><a class="el" href="../../d3/de8/group__atomic.html#gga0411cd49bb5b71852cecd93bcbf0ca2daa5df71bfeb8f16c508776c55e613ca86">ATOMIC_RELAXED</a></li>
<li><a class="el" href="../../d3/de8/group__atomic.html#gga0411cd49bb5b71852cecd93bcbf0ca2da2b107cf2c6dce64b5e987cd0d4b4f8d3">ATOMIC_RELEASE</a></li>
<li><a class="el" href="../../d3/de8/group__atomic.html#gga0411cd49bb5b71852cecd93bcbf0ca2da388308897863e62b26231a119b5020bc">ATOMIC_SEQ_CST</a></li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>Pointer to the atomic integer. </td></tr>
    <tr><td class="paramname">val</td><td>The value to store. </td></tr>
    <tr><td class="paramname">order</td><td>Memory ordering constraint. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaeed40339978572d732a2aacfed0bf998" name="gaeed40339978572d732a2aacfed0bf998"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaeed40339978572d732a2aacfed0bf998">&#9670;&#160;</a></span>atomic_store_ptr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void atomic_store_ptr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../dc/d3d/structatomic__ptr.html">atomic_ptr</a> *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uintptr_t&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>order</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Atomically stores a value into an atomic pointer. </p>
<p>Valid memory orderings are:</p><ul>
<li><a class="el" href="../../d3/de8/group__atomic.html#gga0411cd49bb5b71852cecd93bcbf0ca2daa5df71bfeb8f16c508776c55e613ca86">ATOMIC_RELAXED</a></li>
<li><a class="el" href="../../d3/de8/group__atomic.html#gga0411cd49bb5b71852cecd93bcbf0ca2da2b107cf2c6dce64b5e987cd0d4b4f8d3">ATOMIC_RELEASE</a></li>
<li><a class="el" href="../../d3/de8/group__atomic.html#gga0411cd49bb5b71852cecd93bcbf0ca2da388308897863e62b26231a119b5020bc">ATOMIC_SEQ_CST</a></li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>Pointer to the atomic pointer. </td></tr>
    <tr><td class="paramname">val</td><td>The value to store. </td></tr>
    <tr><td class="paramname">order</td><td>Memory ordering constraint. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga912bb344c291acd613c709eaab7be976" name="ga912bb344c291acd613c709eaab7be976"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga912bb344c291acd613c709eaab7be976">&#9670;&#160;</a></span>atomic_sub_fetch_32()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint32_t atomic_sub_fetch_32 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../dc/d44/structatomic__32.html">atomic_32</a> *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>order</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Atomically subtracts a value from an atomic uint32_t and returns the new value. </p>
<p>All memory orderings are valid.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>Pointer to the atomic uint32_t. </td></tr>
    <tr><td class="paramname">val</td><td>The value to subtract. </td></tr>
    <tr><td class="paramname">order</td><td>Memory ordering constraint. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new value after subtraction. </dd></dl>

</div>
</div>
<a id="ga7366eeb0afebd87dd96739cd5dd0666e" name="ga7366eeb0afebd87dd96739cd5dd0666e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7366eeb0afebd87dd96739cd5dd0666e">&#9670;&#160;</a></span>atomic_sub_fetch_64()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint64_t atomic_sub_fetch_64 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../df/d8a/structatomic__64.html">atomic_64</a> *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>order</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Atomically subtracts a value from an atomic uint64_t and returns the new value. </p>
<p>All memory orderings are valid.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>Pointer to the atomic uint64_t. </td></tr>
    <tr><td class="paramname">val</td><td>The value to subtract. </td></tr>
    <tr><td class="paramname">order</td><td>Memory ordering constraint. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new value after subtraction. </dd></dl>

</div>
</div>
<a id="ga9e217ddededa9cc15a6c4d1db7c75179" name="ga9e217ddededa9cc15a6c4d1db7c75179"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9e217ddededa9cc15a6c4d1db7c75179">&#9670;&#160;</a></span>atomic_sub_fetch_int()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int atomic_sub_fetch_int </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../db/d09/structatomic__int.html">atomic_int</a> *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>order</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Atomically subtracts a value from an atomic integer and returns the new value. </p>
<p>All memory orderings are valid.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>Pointer to the atomic integer. </td></tr>
    <tr><td class="paramname">val</td><td>The value to subtract. </td></tr>
    <tr><td class="paramname">order</td><td>Memory ordering constraint. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new value after subtraction. </dd></dl>

</div>
</div>
<a id="ga84897bb8477b0f4e9996071896be47ce" name="ga84897bb8477b0f4e9996071896be47ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga84897bb8477b0f4e9996071896be47ce">&#9670;&#160;</a></span>atomic_test_and_set()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool atomic_test_and_set </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../db/d98/structatomic__bool.html">atomic_bool</a> *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>order</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Atomically sets an atomic boolean and returns the old value. </p>
<p>All memory orderings are valid.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>Pointer to the atomic boolean. </td></tr>
    <tr><td class="paramname">order</td><td>Memory ordering constraint. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaf9cc7332f27e6373097d1b8093be299f" name="gaf9cc7332f27e6373097d1b8093be299f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf9cc7332f27e6373097d1b8093be299f">&#9670;&#160;</a></span>atomic_thread_fence()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void atomic_thread_fence </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>order</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Establishes a memory fence between threads. </p>
<p>Prevents certain memory operations issued before the fence from being reordered with memory operations issued after the fence, according to the specified memory ordering constraint.</p>
<p>This function does not access or modify any atomic object; it only enforces ordering constraints on memory operations as observed by other threads.</p>
<p>All memory orderings are valid.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">order</td><td>Memory ordering constraint. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga62235210f5186281d0a45f5f7d9b51e0" name="ga62235210f5186281d0a45f5f7d9b51e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga62235210f5186281d0a45f5f7d9b51e0">&#9670;&#160;</a></span>atomic_xor_fetch_32()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint32_t atomic_xor_fetch_32 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../dc/d44/structatomic__32.html">atomic_32</a> *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>order</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Atomically performs a bitwise XOR between an atomic uint32_t and a value, storing the result into the atomic uint32_t and returning it. </p>
<p>All memory orderings are valid.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>Pointer to the atomic uint32_t. </td></tr>
    <tr><td class="paramname">val</td><td>The value to XOR with. </td></tr>
    <tr><td class="paramname">order</td><td>Memory ordering constraint. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new value after the XOR operation. </dd></dl>

</div>
</div>
<a id="gaeae84496d9d07234d55260e583710e6a" name="gaeae84496d9d07234d55260e583710e6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaeae84496d9d07234d55260e583710e6a">&#9670;&#160;</a></span>atomic_xor_fetch_64()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint64_t atomic_xor_fetch_64 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../df/d8a/structatomic__64.html">atomic_64</a> *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>order</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Atomically performs a bitwise XOR between an atomic uint64_t and a value, storing the result into the atomic uint64_t and returning it. </p>
<p>All memory orderings are valid.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>Pointer to the atomic uint64_t. </td></tr>
    <tr><td class="paramname">val</td><td>The value to XOR with. </td></tr>
    <tr><td class="paramname">order</td><td>Memory ordering constraint. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new value after the XOR operation. </dd></dl>

</div>
</div>
<a id="gaddeba6725c63db1f1e70659270aa1ab4" name="gaddeba6725c63db1f1e70659270aa1ab4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaddeba6725c63db1f1e70659270aa1ab4">&#9670;&#160;</a></span>atomic_xor_fetch_int()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int atomic_xor_fetch_int </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../db/d09/structatomic__int.html">atomic_int</a> *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>order</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Atomically performs a bitwise XOR between an atomic integer and a value, storing the result into the atomic integer and returning it. </p>
<p>All memory orderings are valid.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>Pointer to the atomic integer. </td></tr>
    <tr><td class="paramname">val</td><td>The value to XOR with. </td></tr>
    <tr><td class="paramname">order</td><td>Memory ordering constraint. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new value after the XOR operation. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
